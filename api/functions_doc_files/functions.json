[
  
  {
    "Name": "initializeModel",
    "Group": "user",
    "Description": "Initializes a VisionEval model including initializing the file which keeps track of the model run state (ModelState.Rda), initializing a log file, initializing the datastore which stores all model data, parses the model run script to identify modules and the packages they are in by order of execution, checks whether all identified packages are installed and indentified modules exist within those packages, checks whether identified input files exist and comply with specifications, and loads all inputs into datastore.",
    "Arguments": 
    [
      {
        "Name": "ParamDir",
        "Description": "A string identifying the relative or absolute path to the directory where the model parameter and geography definition files are located. The default value is 'defs'."
      },
      {
        "Name": "RunParamFile",
        "Description": "RunParamFile A string identifying the name of a JSON-formatted text file that contains parameters needed to identify and manage the model run. The default value is 'run_parameters.json'."
      },
      {
        "Name": "GeoFile",
        "Description": "A string identifying the name of a text file in comma-separated values format that contains the geographic specifications for the model. The default value is 'geo.csv'."
      },
      {
        "Name": "ModelParamFile",
        "Description": "A string identifying the name of a JSON-formatted text file that contains global model parameters that are important to a model and may be shared by several modules."
      },
      {
        "Name": "LoadDatastore",
        "Description": "A logical identifying whether an existing datastore should be loaded."
      },
      {
        "Name": "DatastoreName",
        "Description": "A string identifying the full path name of a datastore to load or NULL if an existing datastore in the working directory is to be loaded."
      },
      {
        "Name": "SaveDatastore",
        "Description": "A string identifying whether if an existing datastore in the working directory should be saved rather than removed."
      }
    ],
    "Return": "None. The function prints to the log file messages which identify whether or not there are errors in initialization. It also prints a success message if initialization has been successful.",
    "Calls":
    [ 
      "initModelStateFile",
      "initLog",
      "writeLog",
      "loadDatastore",
      "getModelState",
      "initDatastore",
      "readGeography",
      "initDatastoreGeography",
      "loadModelParameters",
      "parseModelScript",
      "checkModulesExist",
      "getModuleSpecs",
      "checkModuleSpecs",
      "simDataTransactions",
      "processModuleInputs",
      "inputsToDatastore"
    ]
  },
  
  {
    "Name": "runModule",
    "Group": "user",
    "Description": "Runs a module for a specified year.",
    "Arguments": 
    [
      {
        "Name": "ModuleName",
        "Description": "A string identifying the name of a module."
      },
      {
        "Name": "PackageName",
        "Description": "A string identifying the name of the package the module is a part of."
      },
      {
        "Name": "RunFor",
        "Description": "A string identifying whether to run the module for all years 'AllYears', only the base year 'BaseYear', or for all years except the base year 'NotBaseYear'."
      },
      {
        "Name": "RunYear",
        "Description": "A string identifying the run year (e.g. '2010'). The default value is the value of the object Year in the global namespace."
      }
    ],
    "Return": "None. The function writes results to the specified locations in the datastore and prints a message to the console when the module is being run.",
    "Calls":
    [ 
      "getModelState",
      "writeLog",
      "processModuleSpecs",
      "readFromTable",
      "getFromDatastore",
      "setInDatastore"
    ]
  },
  
  {
    "Name": "initModelStateFile",
    "Group": "control",
    "Description": "Creates the model state list and loads model run parameters recorded in the 'parameters.json' file into the model state list. It also saves the model state list in a file (ModelState.Rda).",
    "Arguments": 
    [
      {
        "Name": "Dir",
        "Description": "A string identifying the name of the directory where the global parameters file is located. The default value is 'defs'."
      },
      {
        "Name": "ParamFile",
        "Description": "A string identifying the name of the global parameters file. The default value is 'parameters.json'."
      }
    ],
    "Return": "TRUE if the model state list is created and file is saved. It creates the model state list and loads parameters recorded in the 'run_parameters.json' file into the model state lists and saves a model state file.",
    "Calls": 
    [ 
    ]
  },
  
  {
    "Name": "setModelState",
    "Group": "control",
    "Description": "Updates the list that keeps track of the model state with list of components to update and resaves in the model state file.",
    "Arguments": 
    [
      {
        "Name": "ChangeState_ls",
        "Description": "A named list of components to change in ModelState_ls."
      },
      {
        "Name": "FileName",
        "Description": "A string identifying the name of the file that contains the ModelState_ls list. The default name is 'ModelState.Rda'."
      }
    ],
    "Return": "TRUE if the model state list and file are changed.",
    "Calls":
    [ 
    ]
  },
  
   {
    "Name": "getModelState",
    "Group": "control",
    "Description": "Reads components of theModelState_ls list that keeps track of the model state.",
    "Arguments": 
    [
      {
        "Name": "Names_",
        "Description": "A string vector of the components to extract from the ModelState_ls list."
      },
      {
        "Name": "State_ls",
        "Description": "The model state list which by default is ModelState_ls."
      }
    ],
    "Return": "A list containing the specified components from the ModelState_ls list.",
    "Calls":
    [ 
    ]
  },
  
  {
    "Name": "readModelState",
    "Group": "control",
    "Description": "Reads components of the file that saves a copy of the model state.",
    "Arguments": 
    [
      {
        "Name": "Names_",
        "Description": "A string vector of the components to extract from the file which stores the ModelState_ls list."
      },
      {
        "Name": "FileName",
        "Description": "A string vector with the full path name of the model state file."
      }
    ],
    "Return": "A list containing the specified components from the model state file.",
    "Calls":
    [ 
    ]
  },
  
  {
    "Name": "getYears",
    "Group": "user",
    "Description": "Reads the Years component from the the ModelState_ls list.",
    "Arguments": 
    [
    ],
    "Return": "A character vector of the model run years.",
    "Calls":
    [ 
      "getModelState"
    ]
  },
  
  {
    "Name": "initLog",
    "Group": "control",
    "Description": "Creates a log (text file) that stores messages generated during a model run.",
    "Arguments": 
    [
    ],
    "Return": "TRUE if the log is created successfully. It creates a log file in the working directory and identifies the name of the log file in the model state file.",
    "Calls":
    [ 
      "setModelState"
    ]
  },
  
  {
    "Name": "writeLog",
    "Group": "control",
    "Description": "Writes a message to the run log.",
    "Arguments": 
    [
      {
        "Name": "Msg",
        "Description": "A character string."
      },
      {
        "Name": "Print",
        "Description": "If True Msg will be printed in additon to being added to log."
      }
    ],
    "Return": "TRUE if the message is written to the log successfully. It appends the time and the message text to the run log.",
    "Calls":
    [ 
      "getModelState"
    ]
  },
  
  {
    "Name": "loadDatastore",
    "Group": "control",
    "Description": "Copies a saved datastore as the working datastore attributes the global list with related geographic information. This function enables scenario variants to be built from a constant set of starting conditions.",
    "Arguments": 
    [
      {
        "Name": "FileToLoad",
        "Description": "A string identifying the full path name to the saved datastore. Path name can either be relative to the working directory or absolute."
      },
      {
        "Name": "GeoFile",
        "Description": "A string identifying the name of the geography definition file (see 'readGeography' function) that is consistent with the saved datastore. The geography definition file must be located in the 'defs' directory."
      },
      {
        "Name": "SaveDatastore",
        "Description": "A logical identifying whether an existing datastore will be saved. It is renamed by appending the system time to the name. The default value is TRUE."
      }
    ],
    "Return": "TRUE if the datastore is loaded. It copies the saved datastore to working directory as 'datastore.h5'. If a 'datastore.h5' file already exists, it first renames that file as 'archive-datastore.h5'. The function updates information in the model state file regarding the model geography and the contents of the loaded datastore. If the stored file does not exist an error is thrown.",
    "Calls":
    [ 
      "getModelState",
      "setModelState",
      "listDatastore",
      "writeLog"
    ]
  },

  {
    "Name": "readGeography",
    "Group": "control",
    "Description": "Manages the reading and error checking of geographic specifications for the model.",
    "Arguments": 
    [
      {
        "Name": "Dir",
        "Description": "A string identifying the path to the geographic specifications file. Note: don't include the final separator in the path name 'e.g. not defs/'."
      },
      {
        "Name": "GeoFile",
        "Description": "A string identifying the name of the geographic specifications file. This is a csv-formatted text file which contains columns named 'Azone', 'Bzone', 'Czone', and 'Marea'. The 'Azone' column must have zone names in all rows. The 'Bzone' and 'Czone' columns can be unspecified (NA in all rows) or may have have unique names in every row. The 'Marea' column (referring to metropolitan areas) identifies etropolitan areas corresponding to the most detailed level of specified geography (or 'None' no metropolitan area occupies any portion of the zone."
      }
    ],
    "Return": "The value TRUE is returned if the function is successful at reading the file and the specifications are consistent. It stops if there are any errors in the specifications. All of the identified errors are written to the run log. A data frame containing the file entries is added to the model state file as Geo_df'.",
    "Calls":
    [ 
      "checkGeography",
      "writeLog",
      "setModelState"
    ]
  },
 
  {
    "Name": "checkGeography",
    "Group": "control",
    "Description": "Reads the file containing geographic specifications for the model and checks the file entries to determine whether they are internally consistent. This function is called by the readGeography function.",
    "Arguments": 
    [
      {
        "Name": "Directory",
        "Description": "A string identifying the path to the geographic specifications file."
      },
      {
        "Name": "Filename",
        "Description": "A string identifying the name of the geographic specifications file."
      }
    ],
    "Return": "A list having two components. The first component, 'Messages', contains a string vector of error messages. If it has a length of 0 if there are no error messages. The second component, 'Update', is a list of components to update in the model state file. The components of this list include: Geo, a data frame that contains the geographic specifications; BzoneSpecified, a logical identifying whether Bzones are specified; and CzoneSpecified, a logical identifying whether Czones are specified.",
    "Calls":
    [ 
      "writeLog"
    ]
  },
  
  {
    "Name": "initDatastoreGeography",
    "Group": "control",
    "Description": "Initializes tables and writes datasets to the datastore which describe geographic relationships of the model.",
    "Arguments": 
    [
    ],
    "Return": "The function returns TRUE if the geographic tables and datasets are sucessfully written to the datastore.",
    "Calls":
    [ 
      "getModelState",
      "initTable",
      "initDataset",
      "writeToTable",
      "writeLog"
    ]
  },
  
  {
    "Name": "loadModelParameters",
    "Group": "control",
    "Description": "Reads the 'model_parameters.json' file and stores the contents in the 'Global/Model' group of the datastore.",
    "Arguments": 
    [
      {
        "Name": "ModelParamFile",
        "Description": "A string identifying the name of the parameter file. The default value is 'model_parameters.json'."
      }
    ],
    "Return": "TRUE if the model parameters file exists and its values are sucessfully written to the datastore.",
    "Calls":
    [ 
      "getModelState",
      "writeLog",
      "initTable",
      "writeToTable"
    ]
  },
  
  {
    "Name": "parseModelScript",
    "Group": "control",
    "Description": "Reads and parses the model script to identify the sequence of module calls and the associated call arguments.",
    "Arguments": 
    [
      {
        "Name": "FilePath",
        "Description": "A string identifying the relative or absolute path to the model run script is located."
      }
    ],
    "Return": "None. A data frame containing information on the calls to 'runModule' in the order of the calls is added to the ModelState_ls list. Each row represents a module call in order. The columns identify the 'ModuleName', the 'PackageName', and the 'RunFor' value.",
    "Calls":
    [ 
      "writeLog",
      "setModelState"
    ]
  },
  
  {
    "Name": "checkModulesExist",
    "Group": "control",
    "Description": "Checks whether all required module packages are installed and whether listed modules are present in the packages.",
    "Arguments": 
    [
      {
        "Name": "ModuleCalls_df",
        "Description": "A listing of modules called in the 'run_model.R' script as created by the 'parseModelScript' function."
      }
    ],
    "Return": "TRUE if all packages and modules are present and FALSE if not.",
    "Calls":
    [ 
      "writeLog"
    ]
  },
  
  {
    "Name": "getModuleSpecs",
    "Group": "control",
    "Description": "Retrieves the specifications list for a module and returns the specifications list.",
    "Arguments": 
    [
      {
        "Name": "ModuleName",
        "Description": "A string identifying the name of the module."
      },
      {
        "Name": "PackageName",
        "Description": "A string identifying the name of the package that the module is in."
      }
    ],
    "Return": "A specifications list that is the same as the specifications list defined for the module in the package.",
    "Calls":
    [ 
    ]
  },
  
  {
    "Name": "checkModuleSpecs",
    "Group": "control",
    "Description": "Reads a processed module specifications list and checks whether the specifications are complete and whether the values are appropriate.",
    "Arguments": 
    [
      {
        "Name": "Spec_ls",
        "Description": "A list containing the module specifications as produced by the 'processModuleSpecs' function."
      },
      {
        "Name": "ModuleName",
        "Description": "A string that identifies the name of the module (used to identify the module in any error messages.)"
      }
    ],
    "Return": "A vector containing messages identifying any errors that are found.",
    "Calls":
    [ 
    ]
  },
  
  {
    "Name": "processModuleSpecs",
    "Group": "control",
    "Description": "Processes a specifications list and expands items that have multiple NAME listings into multiple items.",
    "Arguments": 
    [
      {
        "Name": "Spec_ls",
        "Description": "A specifications list."
      }
    ],
    "Return": "A standard specifications list with expansion of the multiple item specifications.",
    "Calls":
    [ 
    ]
  },
  
  {
    "Name": "simDataTransactions",
    "Group": "control",
    "Description": "Loads all module specifications in order (by run year) and creates a simulated listing of the data which is in the datastore and the requests of data from the datastore and checks whether tables will be present to put datasets in and that datasets will be present that data is to be retrieved from.",
    "Arguments": 
    [
      {
        "Name": "ModuleCalls_df",
        "Description": "A data frame of module calls as produced by the 'parseModelScript' function."
      }
    ],
    "Return": "None. The function has the side effect of writing messages to the log and stops program execution if there are any errors.",
    "Calls":
    [ 
      "getModelState",
      "getYears",
      "readModelState",
      "checkTableExistence",
      "checkDataset",
      "checkSpecConsistency",
      "processModuleSpecs",
      "getDatasetAttr",
      "writeLog"
    ]
  },
  
  {
    "Name": "checkDataset",
    "Group": "control",
    "Description": "Checks whether a dataset exists in the datastore and returns a TRUE or FALSE value with an attribute of the full path to where the dataset should be located in the datastore.",
    "Arguments": 
    [
      {
        "Name": "Name",
        "Description": "A string identifying the dataset name."
      },
      {
        "Name": "Table",
        "Description": "A string identifying the table the dataset is a part of."
      },
      {
        "Name": "Group",
        "Description": "A string or numeric representation of the group the table is a part of."
      },
      {
        "Name": "DstoreListing_df",
        "Description": "A dataframe which lists the contents of the datastore as contained in the ModelState_ls list."
      }
    ],
    "Return": "A logical identifying whether the dataset is in the datastore. It has an attribute that is a string of the full path to where the dataset should be in the datastore.",
    "Calls":
    [ 
    ]
  },
  
  {
    "Name": "getDatasetAttr",
    "Group": "control",
    "Description": "Retrieves the attributes for a dataset in the datastore",
    "Arguments": 
    [
      {
        "Name": "Name",
        "Description": "A string identifying the dataset name."
      },
      {
        "Name": "Table",
        "Description": "A string identifying the table the dataset is a part of."
      },
      {
        "Name": "Group",
        "Description": "A string or numeric representation of the group the table is a part of."
      },
      {
        "Name": "DstoreListing_df",
        "Description": "A dataframe which lists the contents of the datastore as contained in the model state file."
      }
    ],
    "Return": "A named list of the dataset attributes.",
    "Calls":
    [ 
    ]
  },
  
  {
    "Name": "checkTableExistence",
    "Group": "control",
    "Description": "Checks whether a table is present in the datastore.",
    "Arguments": 
    [
      {
        "Name": "Table",
        "Description": "A string identifying the table."
      },
      {
        "Name": "Group",
        "Description": "A string or numeric representation of the group the table is a part of."
      },
      {
        "Name": "DstoreListing_df",
        "Description": "A dataframe which lists the contents of the datastore as contained in the model state file."
      }
    ],
    "Return": "A logical identifying whether a table is present in the datastore.",
    "Calls":
    [
    ]
  },
  
  {
    "Name": "getTableLength",
    "Group": "control",
    "Description": "Retrieves the LENGTH attribute for a table in the datastore.",
    "Arguments": 
    [
      {
        "Name": "Table",
        "Description": "A string identifying the table."
      },
      {
        "Name": "Group",
        "Description": "A string or numeric representation of the group the table is a part of."
      },
      {
        "Name": "DstoreListing_df",
        "Description": "A dataframe which lists the contents of the datastore as contained in the model state file."
      }
    ],
    "Return": "A number that is the table length.",
    "Calls":
    [
    ]
  },
  
  {
    "Name": "checkSpecConsistency",
    "Group": "control",
    "Description": "Checks whether the specifications for a dataset are consistent with the data attributes in the datastore",
    "Arguments": 
    [
      {
        "Name": "Spec_ls",
        "Description": "A list of data specifications consistent with a module Get or Set specifications."
      },
      {
        "Name": "DstoreAttr_",
        "Description": "A named list where the components are the attributes of a dataset."
      }
    ],
    "Return": "A list containing two components, Errors and Warnings. If no inconsistencies are found, both components will have zero-length character vectors. If there are one or more inconsistencies, then these components will hold vectors of error and warning messages. Mismatch between UNITS will produce a warning message. All other inconsistencies will produce error messages.",
    "Calls":
    [
    ]
  },
  
  {
    "Name": "checkMatchType",
    "Group": "control",
    "Description": "Checks whether the data type of a data vector is consistent with specifications.",
    "Arguments": 
    [
      {
        "Name": "Data_",
        "Description": "A data vector."
      },
      {
        "Name": "Type",
        "Description": "A string identifying the specified data type."
      },
      {
        "Name": "DataName",
        "Description": "A string identifying the field name of the data being compared (used for composing message identifying non-compliant fields)."
      }
    ],
    "Return": "A list having 2 components, Errors and Warnings. If no error or warning is identified, both components will contain a zero-length character string. If either an error or warning is identified, the relevant component will contain a character string that identifies the data field and the type mismatch.",
    "Calls":
    [
    ]
  },
  
  {
    "Name": "checkMatchConditions",
    "Group": "control",
    "Description": "Checks whether a data vector contains any elements that match a set of conditions.",
    "Arguments": 
    [
      {
        "Name": "Data_",
        "Description": "A vector of data of type integer, double, character, or logical."
      },
      {
        "Name": "Conditions_",
        "Description": "A character vector of valid R comparison expressions or an empty vector if there are no conditions."
      },
      {
        "Name": "DataName",
        "Description": "A string identifying the field name of the data being compared (used for composing message identifying non-compliant fields)."
      },
      {
        "Name": "ConditionType",
        "Description": "ConditionType A string having a value of either PROHIBIT or UNLIKELY, the two data specifications which use conditions."
      }
    ],
    "Return": "A character vector of messages which identify the data field and the condition that is not met. A zero-length vector is returned if none of the conditions are met.",
    "Calls":
    [
    ]
  },
  
  {
    "Name": "checkIsElementOf",
    "Group": "control",
    "Description": "Checks whether a data vector contains any elements that are not in an allowed set of values.",
    "Arguments": 
    [
      {
        "Name": "Data_",
        "Description": "A vector of data of type integer, double, character, or logical."
      },
      {
        "Name": "SetElements_",
        "Description": "A vector of allowed values."
      },
      {
        "Name": "DataName",
        "Description": "A string identifying the field name of the data being compared (used for composing message identifying non-compliant fields)."
      }
    ],
    "Return": "A character vector of messages which identify the data field and the condition that is not met. A zero-length vector is returned if none of the conditions are met.",
    "Calls":
    [
    ]
  },
  
  {
    "Name": "checkDataConsistency",
    "Group": "control",
    "Description": "Checks whether data to be written to a dataset is consistent with the dataset attributes.",
    "Arguments": 
    [
      {
        "Name": "DatasetName",
        "Description": "A string identifying the dataset that is being checked."
      },
      {
        "Name": "Data_",
        "Description": "A vector of values that may be of type integer, double, character, or logical."
      },
      {
        "Name": "DstoreAttr_",
        "Description": "A named list where the components are the attributes of a dataset."
      }
    ],
    "Return": "A list containing two components, Errors and Warnings. If no inconsistencies are found, both components will have zero-length character vectors. If there are one or more inconsistencies, then these components will hold vectors of error and warning messages. Mismatch between UNITS will produce a warning message. All other inconsistencies will produce error messages.",
    "Calls":
    [ 
      "checkMatchType",
      "checkMatchConditions",
      "checkIsElementOf"
    ]
  },
  
  {
    "Name": "listDatastore",
    "Group": "datastore",
    "Description": "Lists the contents of a datastore.",
    "Arguments": 
    [
    ],
    "Return": "TRUE if the listing is successfully read from the datastore and written to the model state file.",
    "Calls":
    [ 
      "getModelState",
      "setModelState"
    ]
  },
  
  {
    "Name": "initDatastore",
    "Group": "datastore",
    "Description": "Creates datastore with starting structure.",
    "Arguments": 
    [
    ],
    "Return": "TRUE if datastore initialization is successful. Calls the listDatastore function which adds a listing of the datastore contents to the model state file.",
    "Calls":
    [ 
      "getModelState",
      "listDatastore"
    ]
  },
  
  {
    "Name": "initTable",
    "Group": "datastore",
    "Description": "Initializes a table in the datastore.",
    "Arguments": 
    [
      {
        "Name": "Spec_ls",
        "Description": "A list containing the standard module 'Set' specifications described in the model system design documentation."
      },
      {
        "Name": "Group",
        "Description": "A string representation of the name of the group the table is to be created in."
      }
    ],
    "Return": "The value TRUE is returned if the function is successful at creating the table. In addition, the listDatastore function is run to update the inventory in the model state file. The function stops if the group in which the table is to be placed does not exist in the datastore and a message is written to the log.",
    "Calls":
    [ 
      "getModelState",
      "listDatastore"
    ]
  },
  
  {
    "Name": "initDataset",
    "Group": "datastore",
    "Description": "Initializes a dataset in a table.",
    "Arguments": 
    [
      {
        "Name": "Spec_ls",
        "Description": "A list containing the standard module 'Set' specifications described in the model system design documentation."
      },
      {
        "Name": "Group",
        "Description": "A string representation of the name of the group the table is to be created in."
      }
    ],
    "Return": "TRUE if dataset is successfully initialized. If the dataset already exists the function throws an error and writes an error message to the log. Updates the model state file.",
    "Calls":
    [ 
      "getModelState",
      "listDatastore"
    ]
  },
  
  {
    "Name": "writeToTable",
    "Group": "datastore",
    "Description": "Writes data to table and initializes dataset if needed.",
    "Arguments": 
    [
      {
        "Name": "Data_",
        "Description": "A vector of data to be written."
      },
      {
        "Name": "Spec_ls",
        "Description": "A list containing the standard module 'Set' specifications described in the model system design documentation."
      },
      {
        "Name": "Group",
        "Description": "A string representation of the name of the datastore group the data is to be written to."
      },
      {
        "Name": "Index",
        "Description": "A numeric vector identifying the positions the data is to be written to."
      }
    ],
    "Return": "TRUE if data is sucessfully written. Updates model state file.",
    "Calls":
    [ 
      "getModelState",
      "checkDataset",
      "initDataset",
      "writeLog",
      "listDatastore"
    ]
  },
  
  {
    "Name": "readFromTable",
    "Group": "datastore",
    "Description": "Reads a dataset from a table.",
    "Arguments": 
    [
      {
        "Name": "Name",
        "Description": "A string identifying the name of the dataset to be read from."
      },
      {
        "Name": "Table",
        "Description": "A string identifying the complete name of the table where the dataset is located."
      },
      {
        "Name": "Group",
        "Description": "A string representation of the name of the datastore group the data is to be read from."
      },
      {
        "Name": "File",
        "Description": "A string representation of the file path of the datastore."
      },
      {
        "Name": "Index",
        "Description": "A numeric vector identifying the positions the data is to be written to. NULL if the entire dataset is to be read."
      }
    ],
    "Return": "A vector of the same type stored in the datastore and specified in the TYPE attribute.",
    "Calls":
    [ 
      "readModelState",
      "checkDataset",
      "writeLog"
    ]
  },
  
  {
    "Name": "createIndex",
    "Group": "control",
    "Description": "Creates an index for reading or writing module data to the datastore.",
    "Arguments": 
    [
      {
        "Name": "Name",
        "Description": "A string identifying the dataset the index is being created for."
      },
      {
        "Name": "Table",
        "Description": "A string identifying the name of the table the index is being created for."
      },
      {
        "Name": "Group",
        "Description": "A string identifying the group the table is located in."
      }
    ],
    "Return": "A function that creates a vector of positions corresponding to the location of the supplied value in the index field.",
    "Calls":
    [ 
      "readFromTable"
    ]
  },
  
  {
    "Name": "initDataList",
    "Group": "control",
    "Description": "Creates a list to be used for transferring data to and from the datastore.",
    "Arguments": 
    [
    ],
    "Return": "A list that has 3 named list components: Global, Year, BaseYear.",
    "Calls":
    [ 
    ]
  },
  
  {
    "Name": "getFromDatastore",
    "Group": "control",
    "Description": "Retrieves datasets identified in a module's 'Get' specifications from the datastore.",
    "Arguments": 
    [
      {
        "Name": "ModuleSpec_ls",
        "Description": "A list of module specifications that is consistent with the VisionEval requirements."
      },
      {
        "Name": "Geo",
        "Description": "A string identifying the name of the geographic area to get the data for. For example, if the module is specified to be run by Azone, then Geo would be the name of a particular Azone."
      },
      {
        "Name": "RunYear",
        "Description": "A string identifying the model year being run. The default is the Year object in the global workspace."
      }
    ],
    "Return": "A list containing all the data sets specified in the module Get specifications for the identified geographic area.",
    "Calls":
    [ 
      "processModuleSpecs",
      "initDataList",
      "getModelState",
      "createIndex",
      "readModelState",
      "checkDataset",
      "readFromTable"
    ]
  },
  
  {
    "Name": "setInDatastore",
    "Group": "control",
    "Description": "Saves to the datastore the data returned in a standard list by a module.",
    "Arguments": 
    [
      {
        "Name": "Data_ls",
        "Description": "A list containing the data to be saved. The list is organized by group, table, and data set."
      },
      {
        "Name": "ModuleSpec_ls",
        "Description": "A list of module specifications that is consistent with the VisionEval requirements."
      },
      {
        "Name": "ModuleName",
        "Description": "A string identifying the name of the module (used to document the module creating the data in the datastore)"
      },
      {
        "Name": "Year",
        "Description": "A string identifying the model run year."
      },
      {
        "Name": "Geo",
        "Description": "A string identifying the name of the geographic area to get the data for. For example, if the module is specified to be run by Azone, then Geo would be the name of a particular Azone."
      }
    ],
    "Return": "A logical value which is TRUE if the data are successfully saved to the datastore.",
    "Calls":
    [ 
      "getModelState",
      "checkTableExistence",
      "processModuleSpecs",
      "createIndex",
      "writeLog",
      "writeToTable"
    ]
  },
  
  {
    "Name": "checkInputYearGeo",
    "Group": "control",
    "Description": "checks the Year and Geo columns of an input file to determine whether they are complete and have no duplications.",
    "Arguments": 
    [
      {
        "Name": "Year_",
        "Description": "The vector extract of the Year column from the input data."
      },
      {
        "Name": "Geo_",
        "Description": "the vector extract of the Geo column from the input data."
      },
      {
        "Name": "Group",
        "Description": "A string identifying the GROUP specification for the data sets contained in the input file."
      },
      {
        "Name": "Table",
        "Description": "A string identifying the TABLE specification for the data sets contained in the input file."
      }
    ],
    "Return": "A list containing the results of the check. The list has two mandatory components and two optional components. CompleteInput is a logical that identifies whether records are present for all years and geographic areas. DupInput identifies where are any redundant year and geography entries. If CompleteInput is FALSE, the list contains a MissingInputs component that is a string identifying the missing year and geography records. If DupInput is TRUE, the list contains a component that is a string identifying the duplicated year and geography records.",
    "Calls":
    [ 
      "getModelState"
    ]
  },
  
  {
    "Name": "findSpec",
    "Group": "control",
    "Description": "Returns the full dataset specification for defined NAME, TABLE, and GROUP.",
    "Arguments": 
    [
      {
        "Name": "Specs_ls",
        "Description": "A standard specifications list for Inp, Get, or Set."
      },
      {
        "Name": "Name",
        "Description": "A string for the name of the dataset."
      },
      {
        "Name": "Table",
        "Description": "A string for the table that the dataset resides in."
      },
      {
        "Name": "Group",
        "Description": "A string for the generic group that the table resides in."
      }
    ],
    "Return": "A list containing the full specifications for the dataset.",
    "Calls":
    [
    ]
  },
  
  {
    "Name": "sortGeoTable",
    "Group": "control",
    "Description": "Returns a data frame whose rows are sorted to match the geography in a specified table in the datastore.",
    "Arguments": 
    [
      {
        "Name": "Data_df",
        "Description": "A data frame that contains a 'Geo' field containing the names of the geographic areas to sort by and any number of additional data fields."
      },
      {
        "Name": "Table",
        "Description": "A string for the table that is to be matched against."
      },
      {
        "Name": "Group",
        "Description": "A string for the generic group that the table resides in."
      }
    ],
    "Return": "The data frame which has been sorted to match the order of geography in the specified table in the datastore.",
    "Calls":
    [ 
      "readFromTable"
    ]
  },
  
  {
    "Name": "processModuleInputs",
    "Group": "control",
    "Description": "Processes input files identified in a module Inp specifications in preparation for saving in the datastore.",
    "Arguments": 
    [
      {
        "Name": "ModuleSpec_ls",
        "Description": "A list of module specifications that is consistent with the VisionEval requirements."
      },
      {
        "Name": "ModuleName",
        "Description": "A string identifying the name of the module (used to document module in error messages)."
      },
      {
        "Name": "Dir",
        "Description": "A string identifying the relative path to the directory where the model inputs are contained."
      }
    ],
    "Return": "A list containing the results of the input processing. The list has two components. The first (Errors) is a vector of identified file and data errors. The second (Data) is a list containing the data in the input files organized in the standard format for data exchange with the datastore.",
    "Calls":
    [ 
      "getModelState",
      "initDataList",
      "checkInputYearGeo",
      "checkDataConsistency",
      "writeLog"
    ]
  },
  
  {
    "Name": "inputsToDatastore",
    "Group": "control",
    "Description": "Takes a list of processed module input files and writes the datasets to the datastore.",
    "Arguments": 
    [
      {
        "Name": "Inputs_ls",
        "Description": "A list processes module inputs as created by the processModuleInputs function."
      },
      {
        "Name": "ModuleSpec_ls",
        "Description": "A list of module specifications that is consistent with the VisionEval requirements."
      },
      {
        "Name": "ModuleName",
        "Description": "A string identifying the name of the module (used to document the dataset in the datastore)."
      }
    ],
    "Return": "A logical indicating successful completion. Most of the outputs of the function are the side effects of writing data to the datastore.",
    "Calls":
    [ 
      "processModuleSpecs",
      "initTable",
      "findSpec",
      "sortGeoTable",
      "writeToTable"
    ]
  },
  
  {
    "Name": "binarySearch",
    "Group": "developer",
    "Description": "Uses a binary search algorithm to find the value of a function parameter for which the function achieves a target value.",
    "Arguments": 
    [
      {
        "Name": "Function",
        "Description": "A function which returns a value which is compared to the Target argument. The function must take as its first argument a value which from the SearchRange_. It must return a value that may be compared to the Target value."
      },
      {
        "Name": "SearchRange_",
        "Description": "A two element numeric vector which has the lowest and highest values of the parameter range within which the search will be carried out."
      },
      {
        "Name": "...",
        "Description": "One or more optional arguments for the Function."
      },
      {
        "Name": "Target",
        "Description": "A numeric value that is compared with the return value of the Function."
      },
      {
        "Name": "MaxIter",
        "Description": "An integer specifying the maximum number of iterations to all the search to attempt."
      },
      {
        "Name": "Tolerance",
        "Description": "A numeric value specifying the proportional difference between the 'Target' and the return value of the Function to determine when the search is complete."
      }
    ],
    "Return": "The value in the 'SearchRange_' for the function parameter which matches the target value.",
    "Calls":
    [
    ]
  },
  
  {
    "Name": "makeModelFormulaString ",
    "Group": "developer",
    "Description": "Creates a string equivalent of a model equation.",
    "Arguments": 
    [
      {
        "Name": "EstimatedModel",
        "Description": "The return value of the lm or glm functions."
      }
    ],
    "Return": "A string expression of the model equation.",
    "Calls":
    [
    ]
  },
  
  {
    "Name": "applyBinomialModel",
    "Group": "developer",
    "Description": "Applies an estimated binomial model to a set of input data.",
    "Arguments": 
    [
      {
        "Name": "Model_ls",
        "Description": "a list which contains the following components: 1) Type - which has a value of binomial; 2) Formula - a string representation of the model equation; 3) Choices - a two-element vector listing the choice set. The first element is the choice that the binary logit model equation predicts the odds of; 4) PrepFun - a function which prepares the input data frame for the model application. If no preparation, this element of the list should not be present or should be set equal to NULL; 5) SearchRange - a two-element numeric vector which specifies the acceptable search range to use when determining the factor for adjusting the model constant."
      },
      {
        "Name": "Data_df",
        "Description": "A data frame containing the data required for applying the model."
      },
      {
        "Name": "TargetProp",
        "Description": "A number identifying a target proportion for the default choice to be achieved for the input data or NULL if there is no target proportion to be achieved."
      },
      {
        "Name": "CheckTargetSearchRange",
        "Description": "A logical identifying whether the function is to only check whether the specified 'SearchRange' for the model will produce acceptable values (i.e. no NA or NaN values). If FALSE (the default), the function will run the model and will not check the target search range."
      }
    ],
    "Return": "A vector of choice values for each record of the input data frame if the model is being run, or if the function is run to only check the target search range, a two-element vector identifying if the search range produces NA or NaN values.",
    "Calls":
    [
      "binarySearch"
    ]
  },
  
  {
    "Name": "applyLinearModel",
    "Group": "developer",
    "Description": "Applies an estimated linear model to a set of input data.",
    "Arguments": 
    [
      {
        "Name": "Model_ls",
        "Description": "A list which contains the following components: 1) Type which has a value of 'linear'; 2) Formula a string representation of the model equation; 3) PrepFun a function which prepares the input data frame for the model application. If no preparation, this element of the list should not be present or should be set equal to NULL; 4) SearchRange a two-element numeric vector which specifies the acceptable search range to use when determining the dispersion factor. 5) OutFun a function that is applied to transform the results of applying the linear model. For example to untransform a power-transformed variable. If no transformation is necessary, this element of the list should not be present or should be set equal to NULL."
      },
      {
        "Name": "Data_df",
        "Description": "A data frame containing the data required for applying the model."
      },
      {
        "Name": "TargetMean",
        "Description": "A number identifying a target mean value to be achieved  or NULL if there is no target."
      },
      {
        "Name": "CheckTargetSearchRange",
        "Description": "a logical identifying whether the function is to only check whether the specified 'SearchRange' for the model will produce acceptable values (i.e. no NA or NaN values). If FALSE (the default), the function will run the model and will not check the target search range."
      }
    ],
    "Return": "A vector of numeric values for each record of the input data frame if the model is being run, or if the function is run to only check the target search range, a summary of predicted values when the model is run with dispersion set at the high value of the search range.",
    "Calls":
    [ 
      "binarySearch"
    ]
  },
  
  {
    "Name": "item",
    "Group": "developer",
    "Description": "Is an alias for the list function whose purpose is to make module specifications easier to read.",
    "Arguments": 
    [
    ],
    "Return": "A list.",
    "Calls":
    [
    ]
  },
  
  {
    "Name": "items",
    "Group": "developer",
    "Description": "Is an alias for the list function whose purpose is to make module specifications easier to read.",
    "Arguments": 
    [
    ],
    "Return": "A list.",
    "Calls":
    [
    ]
  },
  
  {
    "Name": "processEstimationInputs",
    "Group": "developer",
    "Description": "Checks whether specified model estimation data meets specifications and returns the data in a data frame.",
    "Arguments": 
    [
      {
        "Name": "Inp_ls",
        "Description": "A list that describes the specifications for the estimation file. This list must meet the framework standards for specification description."
      },
      {
        "Name": "FileName",
        "Description": "A string identifying the file name. This is the file name without any path information. The file must located in the inst/extdata directory of the package."
      },
      {
        "Name": "ModuleName",
        "Description": "A string identifying the name of the module the estimation data is being used in."
      }
    ],
    "Return": "A data frame containing the estimation data.",
    "Calls":
    [ 
      "checkDataConsistency"
    ]
  },
  
  {
    "Name": "checkModuleOutputs",
    "Group": "developer",
    "Description": "Checks output list produced by a module for consistency with the module's specifications.",
    "Arguments":
    [
      {
        "Name": "Data_ls",
        "Description": "A list of all the datasets returned by a module in the standard list form required by the VisionEval model system."
      },
      {
        "Name": "ModuleSpec_ls",
        "Description": "A list of module specifications in the standard list form required by the VisionEval model system."
      },
      {
        "Name": "ModuleName",
        "Description": "A string identifying the name of the module."
      }
    ],
    "Return": "A character vector containing a list of error messages or having a length of 0 if there are no error messages.",
    "Calls":
    [
      "processModuleSpecs",
      "checkDataConsistency"
    ]
  },
  
  {
    "Name": "testModule",
    "Group": "developer",
    "Description": "Sets up a test environment and tests a module.",
    "Arguments":
    [
      {
        "Name": "ModuleName",
        "Description": "A string identifying the module name."
      },
      {
        "Name": "ParamDir",
        "Description": "A string identifying the location of the directory where the run parameters, model parameters, and geography definition files are located. The default value is defs. This directory should be located in the tests directory."
      },
      {
        "Name": "RunParamFile",
        "Description": "A string identifying the name of the run parameters file. The default value is run_parameters.json."
      },
      {
        "Name": "GeoFile",
        "Description": "A string identifying the name of the file which contains geography definitions."
      },
      {
        "Name": "ModelParamFile",
        "Description": "A string identifying the name of the file which contains model parameters. The default value is model_parameters.json."
      },
      {
        "Name": "LoadDatastore",
        "Description": "A logical value identifying whether to load an existing datastore. If TRUE, it loads the datastore whose name is identified in the run_parameters.json file. If FALSE it initializes a new datastore."
      },
      {
        "Name": "SaveDatastore",
        "Description": "A logical value identifying whether the module outputs will be written to the datastore. If TRUE the module outputs are written to the datastore. If FALSE the outputs are not written to the datastore."
      }
    ],
    "Return": "None. The function writes out messages to the console and to the log as the testing proceeds. These messages include the time when each test starts and when it ends. When a key test fails, requiring a fix before other tests can be run, execution stops and an error message is written to the console. Detailed error messages are also written to the log.",
    "Calls":
    [
      "initModelStateFile",
      "initLog",
      "writeLog",
      "getModelState",
      "loadDatastore",
      "initDatastore",
      "readGeography",
      "initDatastoreGeography",
      "loadModelParameters",
      "processModuleSpecs",
      "checkModuleSpecs",
      "processModuleInputs",
      "inputsToDatastore",
      "checkDataset",
      "getYears",
      "getFromDatastore",
      "checkModuleOutputs",
      "readFromTable",
      "setInDatastore"
    ]
  }
  
]
