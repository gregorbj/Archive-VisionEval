var functionDetails = [
{"name":"getYears","details":"<h2>Function: getYears<\/h2> <h3>Description<\/h3> <p> `getYears` a visioneval framework model user function that reads the Years component from the the model state file.<\/p> <h3>Details<\/h3> <p> This is a convenience function to make it easier to retrieve the Years component of the model state file which lists all of the specified model run years. If the Years component includes the base year, then the returned vector of years places the base year first in the order. This ordering is important because some modules calculate future year values by pivoting off of base year values so the base year must be run first.<\/p> <h3>Arguments<\/h3> <ul> <li>None<\/li> <\/ul> <h3>Return Value<\/h3> <p> A character vector of the model run years.<\/p>"},
{"name":"initializeModel","details":"<h2>Function: initializeModel<\/h2> <h3>Description<\/h3> <p> `initializeModel` a visioneval framework model user function that initializes a VisionEval model, loading all parameters and inputs, and making checks to ensure that model can run successfully.<\/p> <h3>Details<\/h3> <p> This function does several things to initialize the model environment and datastore including: 1) Initializing a file that is used to keep track of the state of key model run variables and the datastore; 2) Initializes a log to which messages are written; 3) Creates the datastore and initializes its structure, reads in and checks the geographic specifications and initializes the geography in the datastore, or loads an existing datastore if one has been identified; 4) Parses the model run script to identify the modules in their order of execution and checks whether all the identified packages are installed and the modules exist in the packages; 5) Checks that all data requested from the datastore will be available when it is requested and that the request specifications match the datastore specifications; 6) Checks all of the model input files to determine whether they they are complete and comply with specifications.<\/p> <h3>Arguments<\/h3> <ul> <li>ParamDir: A string identifying the relative or absolute path to the directory where the parameter and geography definition files are located. The default value is defs.<\/li> <li>RunParamFile: A string identifying the name of a JSON-formatted text file that contains parameters needed to identify and manage the model run. The default value is run_parameters.json.<\/li> <li>GeoFile: A string identifying the name of a text file in comma-separated values format that contains the geographic specifications for the model. The default value is geo.csv.<\/li> <li>ModelParamFile: A string identifying the name of a JSON-formatted text file that contains global model parameters that are important to a model and may be shared by several modules.<\/li> <li>LoadDatastore: A logical identifying whether an existing datastore should be loaded.<\/li> <li>DatastoreName: A string identifying the full path name of a datastore to load or NULL if an existing datastore in the working directory is to be loaded.<\/li> <li>SaveDatastore: A string identifying whether if an existing datastore in the working directory should be saved rather than removed.<\/li> <\/ul> <h3>Return Value<\/h3> <p> None. The function prints to the log file messages which identify whether or not there are errors in initialization. It also prints a success message if initialization has been successful.<\/p>"},
{"name":"readDatastoreTables","details":"<h2>Function: readDatastoreTables<\/h2> <h3>Description<\/h3> <p> `readDatastoreTables` a visioneval framework model user function that reads datasets from one or more tables in a specified group in one or more datastores<\/p> <h3>Details<\/h3> <p> This function can read multiple datasets in one or more tables in a group. More than one datastore my be specified so that if datastore references are used in a model run, datasets from the referenced datastores may be queried as well. Note that the capability for querying multiple datastores is only for the purpose of querying datastores for a single model scenario. This capability should not be used to compare multiple scenarios. The function does not segregate datasets by datastore. Attempting to use this function to compare multiple scenarios could produce unpredictable results.<\/p> <h3>Arguments<\/h3> <ul> <li>Tables_ls: a named list where the name of each component is the name of a table in a datastore group and the value is a string vector of the names of the datasets to be retrieved.<\/li> <li>Group: a string that is the name of the group to retrieve the table datasets from.<\/li> <li>DstoreLocs_: a string vector identifying the paths to all of the datastores to extract the datasets from. Each entry must be the full relative path to a datastore (e.g. 'tests/Datastore').<\/li> <li>DstoreType: a string identifying the type of datastore (e.g. 'RD', 'H5'). Note<\/li> <\/ul> <h3>Return Value<\/h3> <p> A named list having two components. The 'Data' component is a list containing the datasets from the datastores where the name of each component of the list is the name of a table from which identified datasets are retrieved and the value is a data frame containing the identified datasets. The 'Missing' component is a list which identifies the datasets that are missing in each table.<\/p>"},
{"name":"runModule","details":"<h2>Function: runModule<\/h2> <h3>Description<\/h3> <p> `runModule` a visioneval framework model user function that runs a module.<\/p> <h3>Details<\/h3> <p> This function runs a module for a specified year.<\/p> <h3>Arguments<\/h3> <ul> <li>ModuleName: A string identifying the name of a module object.<\/li> <li>PackageName: A string identifying the name of the package the module is a part of.<\/li> <li>RunFor: A string identifying whether to run the module for all years AllYears, only the base year BaseYear, or for all years except the base year NotBaseYear.<\/li> <li>RunYear: A string identifying the run year.<\/li> <li>StopOnErr: A logical identifying whether model execution should be stopped if the module transmits one or more error messages or whether execution should continue with the next module. The default value is TRUE. This is how error handling will ordinarily proceed during a model run. A value of FALSE is used when 'Initialize' modules in packages are run during model initialization. These 'Initialize' modules are used to check and preprocess inputs. For this purpose, the module will identify any errors in the input data, the 'initializeModel' function will collate all the data errors and print them to the log.<\/li> <\/ul> <h3>Return Value<\/h3> <p> None. The function writes results to the specified locations in the datastore and prints a message to the console when the module is being run.<\/p>"},
{"name":"addErrorMsg","details":"<h2>Function: addErrorMsg<\/h2> <h3>Description<\/h3> <p> `addErrorMsg` a visioneval framework module developer function that adds an error message to the Errors component of the module results list that is passed back to the framework.<\/p> <h3>Details<\/h3> <p> This function is a convenience function for module developers for passing error messages back to the framework. The preferred method for handling errors in module execution is for the module to handle the error by passing one or more error messages back to the framework. The framework will then write error messages to the log and stop execution. Error messages are stored in a component of the returned list called Errors. This component is a string vector where each element is an error message. The addErrorMsg will create the Error component if it does not already exist and will add an error message to the vector.<\/p> <h3>Arguments<\/h3> <ul> <li>ResultsListName: the name of the results list given as a character string<\/li> <li>ErrMsg: a character string that contains the error message<\/li> <\/ul> <h3>Return Value<\/h3> <p> None. The function modifies the results list by adding an error message to the Errors component of the results list. It creates the Errors component if it does not already exist.<\/p>"},
{"name":"addWarningMsg","details":"<h2>Function: addWarningMsg<\/h2> <h3>Description<\/h3> <p> `addWarningMsg` a visioneval framework module developer function that adds an warning message to the Warnings component of the module results list that is passed back to the framework.<\/p> <h3>Details<\/h3> <p> This function is a convenience function for module developers for passing warning messages back to the framework. The preferred method for handling warnings in module execution is for the module to handle the warning by passing one or more warning messages back to the framework. The framework will then write warning messages to the log and stop execution. Warning messages are stored in a component of the returned list called Warnings. This component is a string vector where each element is an warning message. The addWarningMsg will create the Warning component if it does not already exist and will add a warning message to the vector.<\/p> <h3>Arguments<\/h3> <ul> <li>ResultsListName: the name of the results list given as a character string<\/li> <li>WarnMsg: a character string that contains the warning message<\/li> <\/ul> <h3>Return Value<\/h3> <p> None. The function modifies the results list by adding a warning message to the Warnings component of the results list. It creates the Warnings component if it does not already exist.<\/p>"},
{"name":"applyBinomialModel","details":"<h2>Function: applyBinomialModel<\/h2> <h3>Description<\/h3> <p> `applyBinomialModel` a visioneval framework module developer function that applies an estimated binomial model to a set of input data.<\/p> <h3>Details<\/h3> <p> The function calculates the result of applying a binomial logit model to a set of input data. If a target proportion (TargetProp) is specified, the function calls the 'binarySearch' function to calculate an adjustment to the constant of the model equation so that the population proportion matches the target proportion. The function will also test whether the target search range specified for the model will produce acceptable values.<\/p> <h3>Arguments<\/h3> <ul> <li>Model_ls: a list which contains the following components: 'Type' which has a value of 'binomial'; 'Formula' a string representation of the model equation; 'Choices' a two-element vector listing the choice set. The first element is the choice that the binary logit model equation predicts the odds of; 'PrepFun' a function which prepares the input data frame for the model application. If no preparation, this element of the list should not be present or should be set equal to NULL; 'SearchRange' a two-element numeric vector which specifies the acceptable search range to use when determining the factor for adjusting the model constant. 'RepeatVar' a string which identifies the name of a field to use for repeated draws of the model. This is used in the case where for example the input data is households and the output is vehicles and the repeat variable is the number of vehicles in the household. 'ApplyRandom' a logical identifying whether the results will be affected by random draws (i.e. if a random number in range 0 - 1 is less than the computed probability) or if a probability cutoff is used (i.e. if the computed probability is greater then 0.5). This is an optional component. If it isn't present, the function runs with ApplyRandom = TRUE.<\/li> <li>Data_df: a data frame containing the data required for applying the model.<\/li> <li>TargetProp: a number identifying a target proportion for the default choice to be achieved for the input data or NULL if there is no target proportion to be achieved.<\/li> <li>CheckTargetSearchRange: a logical identifying whether the function is to only check whether the specified 'SearchRange' for the model will produce acceptable values (i.e. no NA or NaN values). If FALSE (the default), the function will run the model and will not check the target search range.<\/li> <li>ApplyRandom: a logical identifying whether the outcome will be be affected by random draws (i.e. if a random number in range 0 - 1 is less than the computed probability) or if a probability cutoff is used (i.e. if the computed probability is greater than 0.5)<\/li> <li>ReturnProbs: a logical identifying whether to return the calculated probabilities rather than the assigned results. The default value is FALSE.<\/li> <\/ul> <h3>Return Value<\/h3> <p> a vector of choice values for each record of the input data frame if the model is being run, or if the function is run to only check the target search range, a two-element vector identifying if the search range produces NA or NaN values.<\/p>"},
{"name":"applyLinearModel","details":"<h2>Function: applyLinearModel<\/h2> <h3>Description<\/h3> <p> `applyLinearModel` a visioneval framework module developer function that applies an estimated linear model to a set of input data.<\/p> <h3>Details<\/h3> <p> The function calculates the result of applying a linear regression model to a set of input data. If a target mean value (TargetMean) is specified, the function calculates a standard deviation of a sampling distribution which is applied to linear model results. For each value returned by the linear model, a sample is drawn from a normal distribution where the mean value of the distribution is the linear model result and the standard deviation of the distibution is calculated by the binary search to match the population mean value to the target mean value. This process is meant to be applied to linear model where the dependent variable is power transformed. Applying the sampling distribution to the linear model results increases the dispersion of results to match the observed dispersion and also matches the mean values of the untransformed results. This also enables the model to be applied to situations where the mean value is different than the observed mean value.<\/p> <h3>Arguments<\/h3> <ul> <li>Model_ls: a list which contains the following components: 'Type' which has a value of 'linear'; 'Formula' a string representation of the model equation; 'PrepFun' a function which prepares the input data frame for the model application. If no preparation, this element of the list should not be present or should be set equal to NULL; 'SearchRange' a two-element numeric vector which specifies the acceptable search range to use when determining the dispersion factor. 'OutFun' a function that is applied to transform the results of applying the linear model. For example to untransform a power-transformed variable. If no transformation is necessary, this element of the list should not be present or should be set equal to NULL.<\/li> <li>Data_df: a data frame containing the data required for applying the model.<\/li> <li>TargetMean: a number identifying a target mean value to be achieved  or NULL if there is no target.<\/li> <li>CheckTargetSearchRange: a logical identifying whether the function is to only check whether the specified 'SearchRange' for the model will produce acceptable values (i.e. no NA or NaN values). If FALSE (the default), the function will run the model and will not check the target search range.<\/li> <\/ul> <h3>Return Value<\/h3> <p> a vector of numeric values for each record of the input data frame if the model is being run, or if the function is run to only check the target search range, a summary of predicted values when the model is run with dispersion set at the high value of the search range.<\/p>"},
{"name":"binarySearch","details":"<h2>Function: binarySearch<\/h2> <h3>Description<\/h3> <p> `binarySearch` a visioneval framework module developer function that uses a binary search algorithm to find the value of a function parameter for which the function achieves a target value.<\/p> <h3>Details<\/h3> <p> A binary search algorithm is used by several modules to calibrate the intercept of a binary logit model to match a specified proportion or to calibrate a dispersion parameter for a linear model to match a mean value. This function implements a binary search algorithm in a consistent manner to be used in all modules that need it. It is written to work with stochastic models which by their nature don't produce the same outputs given the same inputs and so will not converge reliably. To deal with the stochasticity, this function uses a successive averaging  approach to smooth out the effect of stochastic variation on reliable convergence. Rather than use the results of a single search iteration to determine the next value range to use in the search, a weighted average of previous values is used with the more recent values being weighted more heavily.<\/p> <h3>Arguments<\/h3> <ul> <li>Function: a function which returns a value which is compared to the 'Target' argument. The function must take as its first argument a value which from the 'SearchRange_'. It must return a value that may be compared to the 'Target' value.<\/li> <li>SearchRange_: a two element numeric vector which has the lowest and highest values of the parameter range within which the search will be carried out.<\/li> <li>...: one or more optional arguments for the 'Function'.<\/li> <li>Target: a numeric value that is compared with the return value of the 'Function'.<\/li> <li>DoWtAve: a logical indicating whether successive weighted averaging is to be done. This is useful for getting stable results for stochastic calculations.<\/li> <li>MaxIter: an integer specifying the maximum number of iterations to all the search to attempt.<\/li> <li>Tolerance: a numeric value specifying the proportional difference between the 'Target' and the return value of the 'Function' to determine when the search is complete.<\/li> <\/ul> <h3>Return Value<\/h3> <p> the value in the 'SearchRange_' for the function parameter which matches the target value.<\/p>"},
{"name":"checkModuleOutputs","details":"<h2>Function: checkModuleOutputs<\/h2> <h3>Description<\/h3> <p> `checkModuleOutputs` a visioneval framework module developer function that checks output list produced by a module for consistency with the module's specifications.<\/p> <h3>Details<\/h3> <p> This function is used to check whether the output list produced by a module is consistent with the module's specifications. If there are any specifications for creating tables, the function checks whether the output list contains the table(s), if the LENGTH attribute of the table(s) are present, and if the LENGTH attribute(s) are consistent with the length of the datasets to be saved in the table(s). Each of the datasets in the output list are checked against the specifications. These include checking that the data type is consistent with the specified type and whether all values are consistent with PROHIBIT and ISELEMENTOF conditions. For character types, a check is made to ensure that a SIZE attribute exists and that the size is sufficient to store all characters.<\/p> <h3>Arguments<\/h3> <ul> <li>Data_ls: A list of all the datasets returned by a module in the standard list form required by the VisionEval model system.<\/li> <li>ModuleSpec_ls: A list of module specifications in the standard list form required by the VisionEval model system.<\/li> <li>ModuleName: A string identifying the name of the module.<\/li> <\/ul> <h3>Return Value<\/h3> <p> A character vector containing a list of error messages or having a length of 0 if there are no error messages.<\/p>"},
{"name":"documentModule","details":"<h2>Function: documentModule<\/h2> <h3>Description<\/h3> <p> `documentModule` a visioneval framework module developer function that creates a vignettes directory if one does not exist and produces module documentation in markdown format which is saved in the vignettes directory.<\/p> <h3>Details<\/h3> <p> This function produces documentation for a module in markdown format. A 'vignettes' directory is created if it does not exist and the markdown file and any associated resources such as image files are saved in that directory. The function is meant to be called within and at the end of the module script. The documentation is created from a commented block within the module script which is enclosed by the opening tag, <doc>, and the closing tag, <\/doc>. (Note, these tags must be commented along with all the other text in the block). This commented block may also include tags which identify resources to include within the documentation. These tags identify the type of resource and the name of the resource which is located in the 'data' directory. A colon (:) is used to separate the resource type and resource name identifiers. For example: <txt:DvmtModel_ls$EstimationStats$NonMetroZeroDvmt_GLM$Summary> is a tag which will insert text which is located in a component of the DvmtModel_ls list that is saved as an rdata file in the 'data' directory (i.e. data/DvmtModel_ls.rda). The following 3 resource types are recognized: * txt - a vector of strings which are inserted as lines of text in a code block * fig - a png file which is inserted as an image * tab - a matrix or data frame which is inserted as a table The function also reads in the module specifications and creates tables that document user input files, data the module gets from the datastore, and the data the module produces that is saved in the datastore. This function is intended to be called in the R script which defines the module. It is placed near the end of the script (after the portions of the script which estimate module parameters and define the module specifications) so that it is run when the package is built. It may not properly in other contexts.<\/p> <h3>Arguments<\/h3> <ul> <li>ModuleName: A string identifying the name of the module (e.g. 'CalculateHouseholdDvmt')<\/li> <\/ul> <h3>Return Value<\/h3> <p> None. The function has the side effects of creating a 'vignettes' directory if one does not exist, copying identified 'fig' resources to the 'vignettes' directory, and saving the markdown documentation file to the 'vignettes' directory. The markdown file is named with the module name and has a 'md' suffix.<\/p>"},
{"name":"getRegisteredGetSpecs","details":"<h2>Function: getRegisteredGetSpecs<\/h2> <h3>Description<\/h3> <p> `getRegisteredGetSpecs` a visioneval framework module developer function that returns a data frame of Get specifications for datasets in the VisionEval name registry.<\/p> <h3>Details<\/h3> <p> The VisionEval name registry (VENameRegistry.json) keeps track of the dataset names created by all registered modules by reading in datasets specified in the module Inp specifications or by returning calculated datasets as specified in the module Set specifications. This function reads in the name registry and returns Get specifications for identified datasets.<\/p> <h3>Arguments<\/h3> <ul> <li>Names_: A character vector of the dataset names to get specifications for.<\/li> <li>Tables_: A character vector of the tables that the datasets are a part of.<\/li> <li>Groups_: A character vector of the groups that the tables are a part of.<\/li> <li>NameRegistryDir: a string identifying the path to the directory where the name registry file is located.<\/li> <\/ul> <h3>Return Value<\/h3> <p> A data frame containing the Get specifications for the identified datasets.<\/p>"},
{"name":"initDataList","details":"<h2>Function: initDataList<\/h2> <h3>Description<\/h3> <p> `initDataList` a visioneval framework module developer function that creates a list to be used for transferring data to and from the datastore.<\/p> <h3>Details<\/h3> <p> This function initializes a list to store data that is transferred from the datastore to a module or returned from a module to be saved in the datastore. The list has 3 named components (Global, Year, and BaseYear). This is the standard structure for data being passed to and from a module and the datastore.<\/p> <h3>Arguments<\/h3> <ul> <li>None<\/li> <\/ul> <h3>Return Value<\/h3> <p> A list that has 3 named list components: Global, Year, BaseYear<\/p>"},
{"name":"item","details":"<h2>Function: item<\/h2> <h3>Description<\/h3> <p> `item` a visioneval framework module developer function that is an alias for the list function whose purpose is to make module specifications easier to read.<\/p> <h3>Details<\/h3> <p> This function defines an alternate name for list. It is used in module specifications to identify data items in the Inp, Get, and Set portions of the specifications.<\/p> <h3>Arguments<\/h3> <ul> <li>None<\/li> <\/ul> <h3>Return Value<\/h3> <p> a list.<\/p>"},
{"name":"items","details":"<h2>Function: items<\/h2> <h3>Description<\/h3> <p> `items` a visioneval framework module developer function that is an alias for the list function whose purpose is to make module specifications easier to read.<\/p> <h3>Details<\/h3> <p> This function defines an alternate name for list. It is used in module specifications to identify a group of data items in the Inp, Get, and Set portions of the specifications.<\/p> <h3>Arguments<\/h3> <ul> <li>None<\/li> <\/ul> <h3>Return Value<\/h3> <p> a list.<\/p>"},
{"name":"loadPackageDataset","details":"<h2>Function: loadPackageDataset<\/h2> <h3>Description<\/h3> <p> `loadPackageDataset` a visioneval framework module developer function which loads a dataset identified by name from the VisionEval package containing the dataset.<\/p> <h3>Details<\/h3> <p> This function is used to load a dataset identified by name from the VisionEval package which contains the dataset. Using this function is the preferred alternative to hard-wiring the loading using package::dataset notation because it enables users to switch between module versions contained in different packages. For example, there may be different versions of the VEPowertrainsAndFuels package which have different default assumptions about light-duty vehicle powertrain mix and characteristics by model year. Using this function, the module developer only needs to identify the dataset name. The function uses DatasetsByPackage_df data frame in the model state list to identify the package which contains the dataset. It then retrieves and returns the dataset<\/p> <h3>Arguments<\/h3> <ul> <li>DatasetName: A string identifying the name of the dataset.<\/li> <\/ul> <h3>Return Value<\/h3> <p> The identified dataset.<\/p>"},
{"name":"makeModelFormulaString","details":"<h2>Function: makeModelFormulaString<\/h2> <h3>Description<\/h3> <p> `makeModelFormulaString` a visioneval framework module developer function that creates a string equivalent of a model equation.<\/p> <h3>Details<\/h3> <p> The return values of model estimation functions such as 'lm' and 'glm' contain a large amount of information in addition to the parameter estimates for the specified model. This is particularly the case when the estimation dataset is large. Most of this information is not needed to apply the model and including it can add substantially to the size of a package that includes several estimated models. All that is really needed to implement an estimated model is an equation of the model terms and estimated coefficients. This function creates a string representation of the model equation.<\/p> <h3>Arguments<\/h3> <ul> <li>EstimatedModel: the return value of the 'lm' or 'glm' functions.<\/li> <\/ul> <h3>Return Value<\/h3> <p> a string expression of the model equation.<\/p>"},
{"name":"processEstimationInputs","details":"<h2>Function: processEstimationInputs<\/h2> <h3>Description<\/h3> <p> `processEstimationInputs` a visioneval framework module developer function that checks whether specified model estimation data meets specifications and returns the data in a data frame.<\/p> <h3>Details<\/h3> <p> This function is used to check whether a specified CSV-formatted data file used in model estimation is correctly formatted and contains acceptable values for all the datasets contained within. The function checks whether the specified file exists in the inst/extdata directory. If the file does not exist, the function stops and transmits a standard error message that the file does not exist. If the file does exist, the function reads the file into the data frame and then checks whether it contains the specified columns and that the data meets all specifications. If any of the specifications are not met, the function stops and transmits an error message. If there are no data errors the function returns a data frame containing the data in the file.<\/p> <h3>Arguments<\/h3> <ul> <li>Inp_ls: A list that describes the specifications for the estimation file. This list must meet the framework standards for specification description.<\/li> <li>FileName: A string identifying the file name. This is the file name without any path information. The file must located in the inst/extdata directory of the package.<\/li> <li>ModuleName: A string identifying the name of the module the estimation data is being used in.<\/li> <\/ul> <h3>Return Value<\/h3> <p> A data frame containing the estimation data according to specifications with data types consistent with specifications and columns not specified removed. Execution stops if any errors are found. Error messages are printed to the console. Warnings are also printed to the console.<\/p>"},
{"name":"readVENameRegistry","details":"<h2>Function: readVENameRegistry<\/h2> <h3>Description<\/h3> <p> `readVENameRegistry` a visioneval framework module developer function that reads the VisionEval name registry and returns a list of data frames containing the Inp and Set specifications.<\/p> <h3>Details<\/h3> <p> The VisionEval name registry (VENameRegistry.json) keeps track of the dataset names created by all registered modules by reading in datasets specified in the module Inp specifications or by returning calculated datasets as specified in the module Set specifications. This function reads the VisionEval name registry and returns a list of data frames containing the registered Inp and Set specifications.<\/p> <h3>Arguments<\/h3> <ul> <li>NameRegistryDir: a string identifying the path to the directory where the name registry file is located.<\/li> <\/ul> <h3>Return Value<\/h3> <p> A list having two components: Inp and Set. Each component is a data frame containing the respective Inp and Set specifications of registered modules.<\/p>"},
{"name":"testModule","details":"<h2>Function: testModule<\/h2> <h3>Description<\/h3> <p> `testModule` a visioneval framework module developer function that sets up a test environment and tests a module.<\/p> <h3>Details<\/h3> <p> This function is used to set up a test environment and test a module to check that it can run successfully in the VisionEval model system. The function sets up the test environment by switching to the tests directory and initializing a model state list, a log file, and a datastore. The user may use an existing datastore rather than initialize a new datastore. The use case for loading an existing datastore is where a package contains several modules that run in sequence. The first module would initialize a datastore and then subsequent modules use the datastore that is modified by testing the previous module. When run this way, it is also necessary to set the SaveDatastore argument equal to TRUE so that the module outputs will be saved to the datastore. The function performs several tests including checking whether the module specifications are written properly, whether the the test inputs are correct and complete and can be loaded into the datastore, whether the datastore contains all the module inputs identified in the Get specifications, whether the module will run, and whether all of the outputs meet the module's Set specifications. The latter check is carried out in large part by the checkModuleOutputs function that is called.<\/p> <h3>Arguments<\/h3> <ul> <li>ModuleName: A string identifying the module name.<\/li> <li>ParamDir: A string identifying the location of the directory where the run parameters, model parameters, and geography definition files are located. The default value is defs. This directory should be located in the tests directory.<\/li> <li>RunParamFile: A string identifying the name of the run parameters file. The default value is run_parameters.json.<\/li> <li>GeoFile: A string identifying the name of the file which contains geography definitions.<\/li> <li>ModelParamFile: A string identifying the name of the file which contains model parameters. The default value is model_parameters.json.<\/li> <li>LoadDatastore: A logical value identifying whether to load an existing datastore. If TRUE, it loads the datastore whose name is identified in the run_parameters.json file. If FALSE it initializes a new datastore.<\/li> <li>SaveDatastore: A logical value identifying whether the module outputs will be written to the datastore. If TRUE the module outputs are written to the datastore. If FALSE the outputs are not written to the datastore.<\/li> <li>DoRun: A logical value identifying whether the module should be run. If FALSE, the function will initialize a datastore, check specifications, and load inputs but will not run the module but will return the list of module specifications. That setting is useful for module development in order to create the all the data needed to assist with module programming. It is used in conjunction with the getFromDatastore function to create the dataset that will be provided by the framework. The default value for this parameter is TRUE. In that case, the module will be run and the results will checked for consistency with the Set specifications.<\/li> <li>RunFor: A string identifying what years the module is to be tested for. The value must be the same as the value that is used when the module is run in a module. Allowed values are 'AllYears', 'BaseYear', and 'NotBaseYear'.<\/li> <li>StopOnErr: A logical identifying whether model execution should be stopped if the module transmits one or more error messages or whether execution should continue with the next module. The default value is TRUE. This is how error handling will ordinarily proceed during a model run. A value of FALSE is used when 'Initialize' modules in packages are run during model initialization. These 'Initialize' modules are used to check and preprocess inputs. For this purpose, the module will identify any errors in the input data, the 'initializeModel' function will collate all the data errors and print them to the log.<\/li> <li>RequiredPackages: A character vector identifying any packages that must be installed in order to test the module because the module either has a soft reference to a module in the package (i.e. the Call spec only identifies the name of the module being called) or a soft reference to a dataset in the module (i.e. only identifies the name of the dataset). The default value is NULL.<\/li> <li>TestGeoName: A character vector identifying the name of the geographic area for which data is to be loaded. This argument has effect only if the DoRun argument is FALSE. It enables the module developer to choose the geographic area data is to be loaded for when developing a module that is run for geography other than the region. For example if a module is run at the Azone level, the user can specify the name of the Azone that data is to be loaded for. If the name is misspecified an error will be flagged.<\/li> <\/ul> <h3>Return Value<\/h3> <p> If DoRun is FALSE, the return value is a list containing the module specifications. If DoRun is TRUE, there is no return value. The function writes out messages to the console and to the log as the testing proceeds. These messages include the time when each test starts and when it ends. When a key test fails, requiring a fix before other tests can be run, execution stops and an error message is written to the console. Detailed error messages are also written to the log.<\/p>"},
{"name":"assignDatastoreFunctions","details":"<h2>Function: assignDatastoreFunctions<\/h2> <h3>Description<\/h3> <p> `assignDatastoreFunctions` a visioneval framework control function that assigns the values of the functions for interacting with the datastore to the functions for the declared datastore type.<\/p> <h3>Details<\/h3> <p> The visioneval framework can work with different types of datastores. For example a datastore which stores datasets in an HDF5 file or a datastore which stores datasets as RData files in a directory hierarchy. This function reads the 'DatastoreType' parameter from the model state file and then assigns the common datastore interaction functions the values of the functions for the declared datastore type.<\/p> <h3>Arguments<\/h3> <ul> <li>DstoreType: A string identifying the datastore type.<\/li> <\/ul> <h3>Return Value<\/h3> <p> None. The function assigns datastore interactions functions to the first position of the search path.<\/p>"},
{"name":"checkDataConsistency","details":"<h2>Function: checkDataConsistency<\/h2> <h3>Description<\/h3> <p> `checkDataConsistency` a visioneval framework control function that checks whether data to be written to a dataset is consistent with the dataset attributes.<\/p> <h3>Details<\/h3> <p> This function compares characteristics of data to be written to a dataset to the dataset attributes to determine whether they are consistent.<\/p> <h3>Arguments<\/h3> <ul> <li>DatasetName: A string identifying the dataset that is being checked.<\/li> <li>Data_: A vector of values that may be of type integer, double, character, or logical.<\/li> <li>DstoreAttr_: A named list where the components are the attributes of a dataset.<\/li> <\/ul> <h3>Return Value<\/h3> <p> A list containing two components, Errors and Warnings. If no inconsistencies are found, both components will have zero-length character vectors. If there are one or more inconsistencies, then these components will hold vectors of error and warning messages. Mismatch between UNITS will produce a warning message. All other inconsistencies will produce error messages.<\/p>"},
{"name":"checkDataset","details":"<h2>Function: checkDataset<\/h2> <h3>Description<\/h3> <p> `checkDataset` a visioneval framework control function that checks whether a dataset exists in the datastore and returns a TRUE or FALSE value with an attribute of the full path to where the dataset should be located in the datastore.<\/p> <h3>Details<\/h3> <p> This function checks whether a dataset exists. The dataset is identified by its name and the table and group names it is in. If the dataset is not in the datastore, an error is thrown. If it is located in the datastore, the full path name to the dataset is returned.<\/p> <h3>Arguments<\/h3> <ul> <li>Name: a string identifying the dataset name.<\/li> <li>Table: a string identifying the table the dataset is a part of.<\/li> <li>Group: a string or numeric representation of the group the table is a part of.<\/li> <li>DstoreListing_df: a dataframe which lists the contents of the datastore as contained in the model state file.<\/li> <\/ul> <h3>Return Value<\/h3> <p> A logical identifying whether the dataset is in the datastore. It has an attribute that is a string of the full path to where the dataset should be in the datastore.<\/p>"},
{"name":"checkGeography","details":"<h2>Function: checkGeography<\/h2> <h3>Description<\/h3> <p> `checkGeography` a visioneval framework control function that checks geographic specifications file for model.<\/p> <h3>Details<\/h3> <p> This function reads the file containing geographic specifications for the model and checks the file entries to determine whether they are internally consistent. This function is called by the readGeography function.<\/p> <h3>Arguments<\/h3> <ul> <li>Directory: A string identifying the path to the geographic specifications file.<\/li> <li>Filename: A string identifying the name of the geographic specifications file.<\/li> <\/ul> <h3>Return Value<\/h3> <p> A list having two components. The first component, 'Messages', contains a string vector of error messages. It has a length of 0 if there are no error messages. The second component, 'Update', is a list of components to update in the model state file. The components of this list include: Geo, a data frame that contains the geographic specifications; BzoneSpecified, a logical identifying whether Bzones are specified; and CzoneSpecified, a logical identifying whether Czones are specified.<\/p>"},
{"name":"checkInputYearGeo","details":"<h2>Function: checkInputYearGeo<\/h2> <h3>Description<\/h3> <p> `checkInputYearGeo` a visioneval framework control function that checks the 'Year' and 'Geo' columns of an input file to determine whether they are complete and have no duplications.<\/p> <h3>Details<\/h3> <p> This function checks the 'Year' and 'Geo' columns of an input file to determine whether there are records for all run years specified for the model and for all geographic areas for the level of geography. It also checks for redundant year and geography entries.<\/p> <h3>Arguments<\/h3> <ul> <li>Year_: the vector extract of the 'Year' column from the input data.<\/li> <li>Geo_: the vector extract of the 'Geo' column from the input data.<\/li> <li>Group: a string identifying the 'GROUP' specification for the data sets contained in the input file.<\/li> <li>Table: a string identifying the 'TABLE' specification for the data sets contained in the input file.<\/li> <\/ul> <h3>Return Value<\/h3> <p> A list containing the results of the check. The list has two mandatory components and two optional components. 'CompleteInput' is a logical that identifies whether records are present for all years and geographic areas. 'DupInput' identifies where are any redundant year and geography entries. If 'CompleteInput' is FALSE, the list contains a 'MissingInputs' component that is a string identifying the missing year and geography records. If 'DupInput' is TRUE, the list contains a component that is a string identifying the duplicated year and geography records.<\/p>"},
{"name":"checkIsElementOf","details":"<h2>Function: checkIsElementOf<\/h2> <h3>Description<\/h3> <p> `checkIsElementOf` a visioneval framework control function that checks whether a data vector contains any elements that are not in an allowed set of values.<\/p> <h3>Details<\/h3> <p> This function is used to check whether categorical data values are consistent with the defined set of allowed values.<\/p> <h3>Arguments<\/h3> <ul> <li>Data_: A vector of data of type integer, double, character, or logical.<\/li> <li>SetElements_: A vector of allowed values.<\/li> <li>DataName: A string identifying the field name of the data being compared (used for composing message identifying non-compliant fields).<\/li> <\/ul> <h3>Return Value<\/h3> <p> A character vector of messages which identify the data field and the condition that is not met. A zero-length vector is returned if none of the conditions are met.<\/p>"},
{"name":"checkMatchConditions","details":"<h2>Function: checkMatchConditions<\/h2> <h3>Description<\/h3> <p> `checkMatchConditions` a visioneval framework control function that checks whether a data vector contains any elements that match a set of conditions.<\/p> <h3>Details<\/h3> <p> This function checks whether any of the values in a data vector match one or more conditions. The conditions are specified in a character vector where each element is either NA (to match for the existence of NA values) or a character representation of a valid R comparison expression for comparing each element with a specified value (e.g. < 0, > 1, != 10). This function is used both for checking for the presence of prohibited values and for the presence of unlikely values.<\/p> <h3>Arguments<\/h3> <ul> <li>Data_: A vector of data of type integer, double, character, or logical.<\/li> <li>Conditions_: A character vector of valid R comparison expressions or an empty vector if there are no conditions.<\/li> <li>DataName: A string identifying the field name of the data being compared (used for composing message identifying non-compliant fields).<\/li> <li>ConditionType: A string having a value of either PROHIBIT or UNLIKELY, the two data specifications which use conditions.<\/li> <\/ul> <h3>Return Value<\/h3> <p> A character vector of messages which identify the data field and the condition that is not met. A zero-length vector is returned if none of the conditions are met.<\/p>"},
{"name":"checkMatchType","details":"<h2>Function: checkMatchType<\/h2> <h3>Description<\/h3> <p> `checkMatchType` a visioneval framework control function that checks whether the data type of a data vector is consistent with specifications.<\/p> <h3>Details<\/h3> <p> This function checks whether the data type of a data vector is consistent with a specified data type. An error message is generated if data can't be coerced into the specified data type without the possibility of error or loss of information (e.g. if a double is coerced to an integer). A warning message is generated if the specified type is 'character' but the input data type is 'integer', 'double' or 'logical' since these can be coerced correctly, but that may not be what is intended (e.g. zone names may be input as numbers). Note that some modules may use NA inputs as a flag to identify case when result does not need to match a target. In this case, R will read in the type of data as logical. In this case, the function sets the data type to be the same as the specification for the data type so the function not flag a data type error.<\/p> <h3>Arguments<\/h3> <ul> <li>Data_: A data vector.<\/li> <li>Type: A string identifying the specified data type.<\/li> <li>DataName: A string identifying the field name of the data being compared (used for composing message identifying non-compliant fields).<\/li> <\/ul> <h3>Return Value<\/h3> <p> A list having 2 components, Errors and Warnings. If no error or warning is identified, both components will contain a zero-length character string. If either an error or warning is identified, the relevant component will contain a character string that identifies the data field and the type mismatch.<\/p>"},
{"name":"checkModuleExists","details":"<h2>Function: checkModuleExists<\/h2> <h3>Description<\/h3> <p> `checkModuleExists` a visioneval framework control function that checks whether a module required to run a model is present.<\/p> <h3>Details<\/h3> <p> This function takes a specified module and package, checks whether the package has been installed and whether the module is in the package. The function returns an error message is the package is not installed or if the module is not present in the package. If the module has been called by another module the value of the 'CalledBy' argument will be used to identify the calling module as well so that the user understands where the call is coming from.<\/p> <h3>Arguments<\/h3> <ul> <li>ModuleName: A string identifying the module name.<\/li> <li>PackageName: A string identifying the package name.<\/li> <li>InstalledPkgs_: A string vector identifying the names of packages that are installed.<\/li> <li>CalledBy: A string vector having two named elements. The value of the 'Module' element is the name of the calling module. The value of the 'Package' element is the name of the package that the calling module is in.<\/li> <\/ul> <h3>Return Value<\/h3> <p> TRUE if all packages and modules are present and FALSE if not.<\/p>"},
{"name":"checkModuleSpecs","details":"<h2>Function: checkModuleSpecs<\/h2> <h3>Description<\/h3> <p> `checkModuleSpecs` a visioneval framework control function that checks all module specifications for completeness and for proper values.<\/p> <h3>Details<\/h3> <p> This function iterates through all the specifications for a module and calls the checkSpec function to check each specification for completeness and for proper values.<\/p> <h3>Arguments<\/h3> <ul> <li>Specs_ls: a module specifications list.<\/li> <li>ModuleName: a string identifying the name of the module. This is used in the error messages to identify which module has errors.<\/li> <\/ul> <h3>Return Value<\/h3> <p> A vector containing messages identifying any errors that are found.<\/p>"},
{"name":"checkSpec","details":"<h2>Function: checkSpec<\/h2> <h3>Description<\/h3> <p> `checkSpec` a visioneval framework control function that checks a single module specification for completeness and for proper values.<\/p> <h3>Details<\/h3> <p> This function checks whether a single module specification (i.e. the specification for a single dataset contains the minimum required attributes and that the values of the attributes are correct.<\/p> <h3>Arguments<\/h3> <ul> <li>Spec_ls: a list containing the specifications for a single item in a module specifications list.<\/li> <li>SpecGroup: a string identifying the specifications group the specification is in (e.g. RunBy, NewInpTable, NewSetTable, Inp, Get, Set). This is used in the error messages to identify which specification has errors.<\/li> <li>SpecNum: an integer identifying which specification in the specifications group has errors.<\/li> <\/ul> <h3>Return Value<\/h3> <p> A vector containing messages identifying any errors that are found.<\/p>"},
{"name":"checkSpecConsistency","details":"<h2>Function: checkSpecConsistency<\/h2> <h3>Description<\/h3> <p> `checkSpecConsistency` a visioneval framework control function that checks whether the specifications for a dataset are consistent with the data attributes in the datastore.<\/p> <h3>Details<\/h3> <p> This function compares the specifications for a dataset identified in a module Get or Set are consistent with the attributes for that data in the datastore.<\/p> <h3>Arguments<\/h3> <ul> <li>Spec_ls: a list of data specifications consistent with a module Get or Set specifications.<\/li> <li>DstoreAttr_: a named list where the components are the attributes of a dataset.<\/li> <\/ul> <h3>Return Value<\/h3> <p> A list containing two components, Errors and Warnings. If no inconsistencies are found, both components will have zero-length character vectors. If there are one or more inconsistencies, then these components will hold vectors of error and warning messages. Mismatch between UNITS will produce a warning message. All other inconsistencies will produce error messages.<\/p>"},
{"name":"checkSpecTypeUnits","details":"<h2>Function: checkSpecTypeUnits<\/h2> <h3>Description<\/h3> <p> `checkSpecTypeUnits` a visioneval framework control function that checks correctness of TYPE, UNITS, MULTIPLIER and YEAR attributes of a specification that has been processed with the parseUnitsSpec function.<\/p> <h3>Details<\/h3> <p> This function checks whether the TYPE and UNITS of a module's specification contain errors. The check is done on a module specification in which the module's UNITS attribute has been parsed by the parseUnitsSpec function to split the name, multiplier, and years parts of the UNITS attribute. The TYPE is checked against the types catalogued in the Types function. The units name in the UNITS attribute is checked against the units names corresponding to each type catalogued in the Types function. The MULTIPLIER is checked to determine whether a value is a valid number, NA, or not a number (NaN). A NA value means that no multiplier was specified (this is OK) a NaN value means that a multiplier that is not a number was specified which is an error. The YEAR attribute is checked to determine whether there is a proper specification if the specified TYPE is currency. If the TYPE is currency, a YEAR must be specified for Get and Set specifications.<\/p> <h3>Arguments<\/h3> <ul> <li>Spec_ls: a list for a single specification (e.g. a Get specification for a dataset) that has been processed with the parseUnitsSpec function to split the name, multiplier, and year elements of the UNITS specification.<\/li> <li>SpecGroup: a string identifying the group that this specification comes from (e.g. Inp, Get, Set).<\/li> <li>SpecNum: a number identifying which specification in the order of the SpecGroup. This is used to identify the subject specification if an error is identified.<\/li> <\/ul> <h3>Return Value<\/h3> <p> A vector containing messages identifying any errors that are found.<\/p>"},
{"name":"checkTableExistence","details":"<h2>Function: checkTableExistence<\/h2> <h3>Description<\/h3> <p> `checkTableExistence` a visioneval framework control function that checks whether a table is present in the datastore.<\/p> <h3>Details<\/h3> <p> This function checks whether a table is present in the datastore.<\/p> <h3>Arguments<\/h3> <ul> <li>Table: a string identifying the table.<\/li> <li>Group: a string or numeric representation of the group the table is a part of.<\/li> <li>DstoreListing_df: a dataframe which lists the contents of the datastore as contained in the model state file.<\/li> <\/ul> <h3>Return Value<\/h3> <p> A logical identifying whether a table is present in the datastore.<\/p>"},
{"name":"checkUnits","details":"<h2>Function: checkUnits<\/h2> <h3>Description<\/h3> <p> `checkUnits` a visioneval framework control function that checks the specified UNITS for a dataset for consistency with the recognized units for the TYPE specification for the dataset. It also splits compound units into elements.<\/p> <h3>Details<\/h3> <p> The visioneval code recognizes 4 simple data types (integer, double, logical, and character) and 9 complex data types (e.g. distance, time, mass). The simple data types can have any units of measure, but the complex data types must use units of measure that are declared in the Types() function. In addition, there is a compound data type that can have units that are composed of the units of two or more complex data types. For example, speed is a compound data type composed of distance divided by speed. With this example, speed in miles per hour would be represented as MI/HR. This function checks the UNITS specification for a dataset for consistency with the recognized units for the given data TYPE. To check the units of a compound data type, the function splits the units into elements and the operators that separate the elements. It identifies the element units, the complex data type for each element and the operators that separate the elements.<\/p> <h3>Arguments<\/h3> <ul> <li>DataType: a string which identifies the data type as specified in the TYPE attribute for a data set.<\/li> <li>Units: a string identifying the measurement units as specified in the UNITS attribute for a data set after processing with the parseUnitsSpec function.<\/li> <\/ul> <h3>Return Value<\/h3> <p> A list which contains the following elements: DataType: a string identifying the data type. UnitType: a string identifying whether the units correspond to a 'simple' data type, a 'complex' data type, or a 'compound' data type. Units: a string identifying the units. Elements: a list containing the elements of a compound units. Components of this list are: Types: the complex type of each element, Units: the units of each element, Operators: the operators that separate the units. Errors: a string containing an error message or character(0) if no error.<\/p>"},
{"name":"convertMagnitude","details":"<h2>Function: convertMagnitude<\/h2> <h3>Description<\/h3> <p> `convertMagnitude` a visioneval framework control function that converts values between different magnitudes such as between dollars and thousands of dollars.<\/p> <h3>Details<\/h3> <p> The visioneval framework stores all quantities in single units to be unambiguous about the data contained in the datastore. For example,  total income for a region would be stored in dollars rather than in thousands of dollars or millions of dollars. However, often inputs for large quantities are expressed in thousands or millions. Also submodels may be estimated using values expressed in multiples, or they might produce results that are multiples. Where that is the case, the framework enables model users and developers to encode the data multiplier in the input file field name or the UNITS specification. The framework functions then use that information to convert units to and from the single units stored in the datastore. This function implements the conversion. The multiplier must be specified in scientific notation used in R with the additional constraint that the digit term must be 1. For example, a multiplier of 1000 would be represented as 1e3. The multiplier is separated from the units name by a period (.). For example if the units of a dataset to be retrieved from the datastore are thousands of miles, the UNITS specification would be written as 'MI.1e3'.<\/p> <h3>Arguments<\/h3> <ul> <li>Values_: a numeric vector of values to convert from one unit to another.<\/li> <li>FromMagnitude: a number or string identifying the magnitude of the units of the input Values_.<\/li> <li>ToMagnitude: a number or string identifying the magnitude to convert the Values_ to.<\/li> <\/ul> <h3>Return Value<\/h3> <p> A numeric vector of values corresponding the the input Values_ but converted from the magnitude identified in the FromMagnitude argument to the magnitude identified in the ToMagnitude argument. If either the FromMagnitude or the ToMagnitude arguments is NA, the original Values_ are returned. The Converted attribute of the returned values is FALSE. Otherwise the conversion is done and the Converted attribute of the returned values is TRUE.<\/p>"},
{"name":"convertUnits","details":"<h2>Function: convertUnits<\/h2> <h3>Description<\/h3> <p> `convertUnits` a visioneval framework control function that converts values between different units of measure for complex and compound data types recognized by the visioneval code.<\/p> <h3>Details<\/h3> <p> The visioneval code recognizes 4 simple data types (integer, double, logical, and character) and 9 complex data types (e.g. distance, time, mass). The simple data types can have any units of measure, but the complex data types must use units of measure that are declared in the Types() function. In addition, there is a compound data type that can have units that are composed of the units of two or more complex data types. For example, speed is a compound data type composed of distance divided by speed. With this example, speed in miles per hour would be represented as MI/HR. This function converts a vector of values from one unit of measure to another unit of measure. For compound data type it combines multiple unit conversions. The framework converts units based on the default units declared in the 'units.csv' model definition file and in UNITS specifications declared in modules.<\/p> <h3>Arguments<\/h3> <ul> <li>Values_: a numeric vector of values to convert from one unit to another.<\/li> <li>DataType: a string identifying the data type.<\/li> <li>FromUnits: a string identifying the units of measure of the Values_.<\/li> <li>ToUnits: a string identifying the units of measure to convert the Values_ to. If the ToUnits are 'default' the Values_ are converted to the default units for the model.<\/li> <\/ul> <h3>Return Value<\/h3> <p> A list containing the converted values and additional information as follows: Values - a numeric vector containing the converted values. FromUnits - a string representation of the units converted from. ToUnits - a string representation of the units converted to. Errors - a string containing an error message or character(0) if no errors. Warnings - a string containing a warning message or character(0) if no warning.<\/p>"},
{"name":"createGeoIndex","details":"<h2>Function: createGeoIndex<\/h2> <h3>Description<\/h3> <p> `createIndex` a visioneval framework control function that creates an index for reading or writing module data to the datastore.<\/p> <h3>Details<\/h3> <p> This function creates indexing functions which return an index to positions in datasets that correspond to positions in an index field of a table. For example if the index field is 'Azone' in the 'Household' table, this function will return a function that when provided the name of a particular Azone, will return the positions corresponding to that Azone.<\/p> <h3>Arguments<\/h3> <ul> <li>Table: A string identifying the name of the table the index is being created for.<\/li> <li>Group: A string identifying the name of the group where the table is located in the datastore.<\/li> <li>RunBy: A string identifying the level of geography the module is being run at (e.g. Azone).<\/li> <li>Geo: A string identifying the geographic unit to create the index for (e.g. the name of a particular Azone).<\/li> <li>GeoIndex_ls: a list of geographic indices used to determine the positions to extract from a dataset corresponding to the specified geography.<\/li> <\/ul> <h3>Return Value<\/h3> <p> A function that creates a vector of positions corresponding to the location of the supplied value in the index field.<\/p>"},
{"name":"createGeoIndexList","details":"<h2>Function: createGeoIndexList<\/h2> <h3>Description<\/h3> <p> `createGeoIndexList` a visioneval framework control function that creates a list containing the geographic indices for tables in the operating datastore for identified tables.<\/p> <h3>Details<\/h3> <p> This function takes a 'Get' or 'Set' specifications list for a module and the 'RunBy' specification and returns a list which has a component for each table identified in the specifications. Each component includes all geographic datasets for the table.<\/p> <h3>Arguments<\/h3> <ul> <li>Specs_ls: A 'Get' or 'Set' specifications list for a module.<\/li> <li>RunBy: The value of the RunBy specification for a module.<\/li> <li>RunYear: A string identifying the model year that is being run.<\/li> <\/ul> <h3>Return Value<\/h3> <p> A list that contains a component for each table identified in the specifications in which each component includes all the geographic datasets for the table represented by the component.<\/p>"},
{"name":"deflateCurrency","details":"<h2>Function: deflateCurrency<\/h2> <h3>Description<\/h3> <p> `deflateCurrency` a visioneval framework control function that converts currency values between different years of measure.<\/p> <h3>Details<\/h3> <p> The visioneval framework stores all currency values in the base year real currency (e.g. dollar) values. However, currency inputs may be in different nominal year currency. Also modules may be estimated using different nominal year currency data. For example, the original vehicle travel model in GreenSTEP used 2001 NHTS data while the newer model uses 2009 NHTS data. The framework enables model uses to specify the currency year in the field name of an input file that contains currency data. Likewise, the currency year can be encoded in the UNIT attributes for a modules Get and Set specifications. The framework converts dollars to and from specified currency year values and base year real dollar values. The model uses a set of deflator values that the user inputs for the region to make the adjustments. These values are stored in the model state list.<\/p> <h3>Arguments<\/h3> <ul> <li>Values_: a numeric vector of values to convert from one currency year to another.<\/li> <li>FromYear: a number or string identifying the currency year of the input Values_.<\/li> <li>ToYear: a number or string identifying the currency year to convert the Values_ to.<\/li> <\/ul> <h3>Return Value<\/h3> <p> A numeric vector of values corresponding the the input Values_ but converted from the currency year identified in the FromYear argument to the currency year identified in the ToYear argument. If either the FromYear or the ToYear arguments is unaccounted for in the deflator series, the original Values_ are returned with a Converted attribute of FALSE. Otherwise the conversion is done and the Converted attribute of the returned values is TRUE.<\/p>"},
{"name":"doProcessInpSpec","details":"<h2>Function: doProcessInpSpec<\/h2> <h3>Description<\/h3> <p> `doProcessInpSpec` a visioneval framework control function that filters out Inp specifications whose OPTIONAL specification attribute is TRUE but the specified input file is not present.<\/p> <h3>Details<\/h3> <p> An Inp specification component may have an OPTIONAL specification whose value is TRUE. If so, and if the specified input file is present, then the input specification needs to be processed. This function checks whether the OPTIONAL specification is present, whether its value is TRUE, and whether the file exists. If all of these are true, then the input specification needs to be processed. The input specification also needs to be processed if it is not optional. A specification is not optional if the OPTIONAL attribute is not present or if it is present and the value is not TRUE. The function returns a list of all the Inp specifications that meet these criteria.<\/p> <h3>Arguments<\/h3> <ul> <li>InpSpecs_ls: A standard specifications list for Inp specifications.<\/li> <li>InputDir: The path to the input directory.<\/li> <\/ul> <h3>Return Value<\/h3> <p> A list containing the Inp specification components that meet the criteria of either not being optional or being optional and the specified input file is present.<\/p>"},
{"name":"expandSpec","details":"<h2>Function: expandSpec<\/h2> <h3>Description<\/h3> <p> `expandSpec` a visioneval framework control function that takes a Inp, Get, or Set specification and processes it to be in a form that can be used by other functions which use the specification in processing inputs or reading from or writing to the datastore. The parseUnitsSpec function is called to parse the UNITS attribute to extract name, multiplier, and year values. When the specification has multiple values for the NAME attribute, the function creates a specification for each name value.<\/p> <h3>Details<\/h3> <p> The VisionEval design allows module developers to assign multiple values to the NAME attributes of a Inp, Get, or Set specification where the other attributes for those named datasets (or fields) are the same. This greatly reduces duplication and the potential for error in writing module specifications. However, other functions that check or use the specifications are not capable of handling specifications which have NAME attributes containing multiple values. This function expands a specification with multiple values for a  NAME attribute into multiple specifications, each with a single value for the NAME attribute. In addition, the function calls the parseUnitsSpec function to extract multiplier and year information from the value of the UNITS attribute. See that function for details.<\/p> <h3>Arguments<\/h3> <ul> <li>SpecToExpand_ls: A standard specifications list for a specification whose NAME attribute has multiple values.<\/li> <li>ComponentName: A string that is the name of the specifications that the specification is a part of (e.g. Inp, Get, Set).<\/li> <\/ul> <h3>Return Value<\/h3> <p> A list of standard specifications lists which has a component for each value in the NAME attribute of the input specifications list.<\/p>"},
{"name":"findSpec","details":"<h2>Function: findSpec<\/h2> <h3>Description<\/h3> <p> `findSpec` a visioneval framework control function that returns the full dataset specification for defined NAME, TABLE, and GROUP.<\/p> <h3>Details<\/h3> <p> This function finds and returns the full specification from a specifications list whose NAME, TABLE and GROUP values correspond to the Name, Table, and Group argument values. The specifications list must be in standard format and must be for only 'Inp', 'Get', or 'Set' specifications.<\/p> <h3>Arguments<\/h3> <ul> <li>Specs_ls: a standard specifications list for 'Inp', 'Get', or 'Set'<\/li> <li>Name: a string for the name of the dataset<\/li> <li>Table: a string for the table that the dataset resides in<\/li> <li>Group: a string for the generic group that the table resides in<\/li> <\/ul> <h3>Return Value<\/h3> <p> A list containing the full specifications for the dataset<\/p>"},
{"name":"getDatasetAttr","details":"<h2>Function: getDatasetAttr<\/h2> <h3>Description<\/h3> <p> `getDatasetAttr` a visioneval framework control function that retrieves the attributes for a dataset in the datastore.<\/p> <h3>Details<\/h3> <p> This function extracts the listed attributes for a specific dataset from the datastore listing.<\/p> <h3>Arguments<\/h3> <ul> <li>Name: a string identifying the dataset name.<\/li> <li>Table: a string identifying the table the dataset is a part of.<\/li> <li>Group: a string or numeric representation of the group the table is a part of.<\/li> <li>DstoreListing_df: a dataframe which lists the contents of the datastore as contained in the model state file.<\/li> <\/ul> <h3>Return Value<\/h3> <p> A named list of the dataset attributes.<\/p>"},
{"name":"getFromDatastore","details":"<h2>Function: getFromDatastore<\/h2> <h3>Description<\/h3> <p> `getFromDatastore` a visioneval framework control function that retrieves datasets identified in a module's 'Get' specifications from the datastore.<\/p> <h3>Details<\/h3> <p> This function retrieves from the datastore all of the data sets identified in a module's 'Get' specifications. If the module's specifications include the name of a geographic area, then the function will retrieve the data for that geographic area.<\/p> <h3>Arguments<\/h3> <ul> <li>ModuleSpec_ls: a list of module specifications that is consistent with the VisionEval requirements<\/li> <li>RunYear: a string identifying the model year being run. The default is the Year object in the global workspace.<\/li> <li>Geo: a string identifying the name of the geographic area to get the data for. For example, if the module is specified to be run by Azone, then Geo would be the name of a particular Azone.<\/li> <li>GeoIndex_ls: a list of geographic indices used to determine the positions to extract from a dataset corresponding to the specified geography.<\/li> <\/ul> <h3>Return Value<\/h3> <p> A list containing all the data sets specified in the module's 'Get' specifications for the identified geographic area.<\/p>"},
{"name":"getModelState","details":"<h2>Function: getModelState<\/h2> <h3>Description<\/h3> <p> `getModelState` a visioneval framework control function that reads components of the list that keeps track of the model state.<\/p> <h3>Details<\/h3> <p> Key variables that are important for managing the model run are stored in a list (ModelState_ls) that is managed in the global environment. This function extracts named components of the list.<\/p> <h3>Arguments<\/h3> <ul> <li>Names_: A string vector of the components to extract from the ModelState_ls list.<\/li> <\/ul> <h3>Return Value<\/h3> <p> A list containing the specified components from the model state file.<\/p>"},
{"name":"getModuleSpecs","details":"<h2>Function: getModuleSpecs<\/h2> <h3>Description<\/h3> <p> `getModuleSpecs` a visioneval framework control function that retrieves the specifications list for a module and returns the specifications list.<\/p> <h3>Details<\/h3> <p> This function loads the specifications for a module in a package. It returns the specifications list.<\/p> <h3>Arguments<\/h3> <ul> <li>ModuleName: A string identifying the name of the module.<\/li> <li>PackageName: A string identifying the name of the package that the module is in.<\/li> <\/ul> <h3>Return Value<\/h3> <p> A specifications list that is the same as the specifications list defined for the module in the package.<\/p>"},
{"name":"getUnits","details":"<h2>Function: getUnits<\/h2> <h3>Description<\/h3> <p> `getUnits` a visioneval framework control function that retrieves the default model units for a vector of complex data types.<\/p> <h3>Details<\/h3> <p> This is a convenience function to make it easier to retrieve the default units for a complex data type (e.g. distance, volume, speed). The default units are the units used to store the complex data type in the datastore.<\/p> <h3>Arguments<\/h3> <ul> <li>Type_: A string vector identifying the complex data type(s).<\/li> <\/ul> <h3>Return Value<\/h3> <p> A string vector identifying the default units for the complex data type(s) or NA if any of the type(s) are not defined.<\/p>"},
{"name":"initDatastoreGeography","details":"<h2>Function: initDatastoreGeography<\/h2> <h3>Description<\/h3> <p> `initDatastoreGeography` a visioneval framework control function that initializes tables and writes datasets to the datastore which describe geographic relationships of the model.<\/p> <h3>Details<\/h3> <p> This function writes tables to the datastore for each of the geographic levels. These tables are then used during a model run to store values that are either specified in scenario inputs or that are calculated during a model run. The function populates the tables with cross-references between geographic levels. The function reads the model geography (Geo_df) from the model state file. Upon successful completion, the function calls the listDatastore function to update the datastore listing in the global list.<\/p> <h3>Arguments<\/h3> <ul> <li>None<\/li> <\/ul> <h3>Return Value<\/h3> <p> The function returns TRUE if the geographic tables and datasets are sucessfully written to the datastore.<\/p>"},
{"name":"initLog","details":"<h2>Function: initLog<\/h2> <h3>Description<\/h3> <p> `initLog` a visioneval framework control function that creates a log (text file) that stores messages generated during a model run.<\/p> <h3>Details<\/h3> <p> This function creates a log file that is a text file which stores messages generated during a model run. The name of the log is 'Log <date> <time>' where '<date>' is the initialization date and '<time>' is the initialization time. The log is initialized with the scenario name, scenario description and the date and time of initialization.<\/p> <h3>Arguments<\/h3> <ul> <li>Suffix: A character string appended to the file name for the log file. For example, if the suffix is 'CreateHouseholds', the log file is named 'Log_CreateHouseholds.txt'. The default value is NULL in which case the suffix is the date and time.<\/li> <\/ul> <h3>Return Value<\/h3> <p> TRUE if the log is created successfully. It creates a log file in the working directory and identifies the name of the log file in the model state file.<\/p>"},
{"name":"initModelStateFile","details":"<h2>Function: initModelStateFile<\/h2> <h3>Description<\/h3> <p> `initModelState` a visioneval framework control function that loads model run parameters into the model state list in the global workspace and saves as file.<\/p> <h3>Details<\/h3> <p> This function creates the model state list and loads model run parameters recorded in the 'parameters.json' file into the model state list. It also saves the model state list in a file (ModelState.Rda).<\/p> <h3>Arguments<\/h3> <ul> <li>Dir: A string identifying the name of the directory where the global parameters, deflator, and default units files are located. The default value is defs.<\/li> <li>ParamFile: A string identifying the name of the global parameters file. The default value is parameters.json.<\/li> <li>DeflatorFile: A string identifying the name of the file which contains deflator values by year (e.g. consumer price index). The default value is deflators.csv.<\/li> <li>UnitsFile: A string identifying the name of the file which contains default units for complex data types (e.g. currency, distance, speed, etc.). The default value is units.csv.<\/li> <\/ul> <h3>Return Value<\/h3> <p> TRUE if the model state list is created and file is saved. It creates the model state list and loads parameters recorded in the 'parameters.json' file into the model state lists and saves a model state file.<\/p>"},
{"name":"inputsToDatastore","details":"<h2>Function: inputsToDatastore<\/h2> <h3>Description<\/h3> <p> `inputsToDatastore` a visioneval framework control function that takes a list of processed module input files and writes the datasets to the datastore.<\/p> <h3>Details<\/h3> <p> This function takes a processed list of input datasets specified by a module created by the application of the 'processModuleInputs' function and writes the datasets in the list to the datastore.<\/p> <h3>Arguments<\/h3> <ul> <li>Inputs_ls: a list processes module inputs as created by the 'processModuleInputs' function.<\/li> <li>ModuleSpec_ls: a list of module specifications that is consistent with the VisionEval requirements.<\/li> <li>ModuleName: a string identifying the name of the module (used to document the dataset in the datastore).<\/li> <\/ul> <h3>Return Value<\/h3> <p> A logical indicating successful completion. Most of the outputs of the function are the side effects of writing data to the datastore.<\/p>"},
{"name":"loadDatastore","details":"<h2>Function: loadDatastore<\/h2> <h3>Description<\/h3> <p> `loadDatastore` a visioneval framework control function that copies an existing saved datastore and writes information to run environment.<\/p> <h3>Details<\/h3> <p> This function copies a saved datastore as the working datastore attributes the global list with related geographic information. This function enables scenario variants to be built from a constant set of starting conditions.<\/p> <h3>Arguments<\/h3> <ul> <li>FileToLoad: A string identifying the full path name to the saved datastore. Path name can either be relative to the working directory or absolute.<\/li> <li>Dir: A string identifying the path of the geography definition file (GeoFile), default to 'defs' relative to the working directory<\/li> <li>GeoFile: A string identifying the name of the geography definition file (see 'readGeography' function) that is consistent with the saved datastore. The geography definition file must be located in the 'defs' directory.<\/li> <li>SaveDatastore: A logical identifying whether an existing datastore will be saved. It is renamed by appending the system time to the name. The default value is TRUE.<\/li> <\/ul> <h3>Return Value<\/h3> <p> TRUE if the datastore is loaded. It copies the saved datastore to working directory as 'datastore.h5'. If a 'datastore.h5' file already exists, it first renames that file as 'archive-datastore.h5'. The function updates information in the model state file regarding the model geography and the contents of the loaded datastore. If the stored file does not exist an error is thrown.<\/p>"},
{"name":"loadModelParameters","details":"<h2>Function: loadModelParameters<\/h2> <h3>Description<\/h3> <p> `loadModelParameters` a visioneval framework control function reads the 'model_parameters.json' file and stores the contents in the 'Global/Model' group of the datastore.<\/p> <h3>Details<\/h3> <p> This function reads the 'model_parameters.json' file in the 'defs' directory which contains parameters specific to a model rather than to a module. These area parameters that may be used by any module. Parameters are specified by name, value, and data type. The function creates a 'Model' group in the 'Global' group and stores the values of the appropriate type in the 'Model' group.<\/p> <h3>Arguments<\/h3> <ul> <li>ModelParamFile: A string identifying the name of the parameter file. The default value is 'model_parameters.json'.<\/li> <\/ul> <h3>Return Value<\/h3> <p> The function returns TRUE if the model parameters file exists and its values are sucessfully written to the datastore.<\/p>"},
{"name":"parseInputFieldNames","details":"<h2>Function: parseInputFieldNames<\/h2> <h3>Description<\/h3> <p> `parseInputFieldNames` a visioneval framework control function that parses the field names of an input file to separate out the field name, currency year (if data is currency type), and value multiplier.<\/p> <h3>Details<\/h3> <p> The field names of input files can be used to encode more information than the name itself. It can also encode the currency year for currency type data and also if the values are in multiples (e.g. thousands of dollars). For currency type data it is mandatory that the currency year be specified so that the data can be converted to base year currency values (e.g. dollars in base year dollars). The multiplier is optional, but needless to say, it can only be applied to numeric data. The function returns a list with a component for each field. Each component identifies the field name, year, multiplier, and error status for the result of parsing the field name. If the field name was parsed successfully, the error status is character(0). If the field name was not successfully parsed, the error status contains an error message, identifying the problem.<\/p> <h3>Arguments<\/h3> <ul> <li>FieldNames_: A character vector containing the field names of an input file.<\/li> <li>Specs_ls: A list of specifications for fields in the input file.<\/li> <li>FileName: A string identifying the name of the file that the field names are from. This is used for writing error messages.<\/li> <\/ul> <h3>Return Value<\/h3> <p> A named list with one component for each field. Each component is a list having 4 named components: Error, Name, Year, Multiplier. The Error component has a value of character(0) if there are no errors or a character vector of error messages if there are errors. The Name component is a string with the name of the field. The Year component is a string with the year component if the data type is currency or NA if the data type is not currency or if the Year component has an invalid value. The Multiplier is a number if the multiplier component is present and is valid. It is NA if there is no multiplier component and NaN if the multiplier is invalid. Each component of the list is named with the value of the Name component (i.e. the field name without the year and multiplier elements.)<\/p>"},
{"name":"parseModelScript","details":"<h2>Function: parseModelScript<\/h2> <h3>Description<\/h3> <p> `parseModel` a visioneval framework control function that reads and parses the model script to identify the sequence of module calls and the associated call arguments.<\/p> <h3>Details<\/h3> <p> This function reads in the model run script and parses the script to identify the sequence of module calls. It extracts each call to 'runModule' and identifies the values assigned to the function arguments. It creates a list of the calls with their arguments in the order of the calls in the script.<\/p> <h3>Arguments<\/h3> <ul> <li>FilePath: A string identifying the relative or absolute path to the model run script is located.<\/li> <li>TestMode: A logical identifying whether the function is to run in test mode. When in test mode the function returns the parsed script but does not change the model state or write results to the log.<\/li> <\/ul> <h3>Return Value<\/h3> <p> A data frame containing information on the calls to 'runModule' in the order of the calls. Each row represents a module call in order. The columns identify the 'ModuleName', the 'PackageName', and the 'RunFor' value.<\/p>"},
{"name":"parseUnitsSpec","details":"<h2>Function: parseUnitsSpec<\/h2> <h3>Description<\/h3> <p> `parseUnitsSpec` a visioneval framework control function that parses the UNITS attribute of a standard Inp, Get, or Set specification for a dataset to identify the units name, multiplier, and year for currency data. Returns a modified specifications list whose UNITS value is only the units name, and includes a MULTIPLIER attribute and YEAR attribute.<\/p> <h3>Details<\/h3> <p> The UNITS component of a specifications list can encode information in addition to the units name. This includes a value units multiplier and in the case of currency values the year for the currency measurement. The multiplier element can only be expressed in scientific notation where the number before the 'e' can only be 1. If the year element for a currency specification is missing, it is replaced by the model base year which is recorded in the model state file. If this is done, a WARN attribute is added to the specifications list notifying the module developer that there is no year element and the model base year will be used when the module is called. The test module function reads this warning and writes it to the module test log. This way the module developer is made aware of the situation so that it may be corrected if necessary. The model user is not bothered by the warning.<\/p> <h3>Arguments<\/h3> <ul> <li>Spec_ls: A standard specifications list for a Inp, Get, or Set item.<\/li> <li>ComponentName: A string that is the name of the specifications the the specification comes from (e.g. Inp, Get, Set).<\/li> <\/ul> <h3>Return Value<\/h3> <p> a list that is a standard specifications list with the addition of a MULTIPLIER component and a YEAR component as well as a modification of the UNIT component. The MULTIPLIER component can have the value of NA, a number, or NaN. The value is NA if the multiplier is missing. It is a number if the multiplier is a valid number. The value is NaN if the multiplier is not a valid number. The YEAR component is a character string that is a 4-digit representation of a year or NA if the component is not a proper year. If the year component is missing from the UNITS specification for currency data, the model base year is substituted. In that case, a WARN attribute is added to the returned specifications list. This is read by the testModule function and written to the module test log to notify the module developer. After the UNITS component has been parsed and the YEAR and MULTIPLIER components extracted, the UNITS component is modified to only be the units name.<\/p>"},
{"name":"processModuleInputs","details":"<h2>Function: processModuleInputs<\/h2> <h3>Description<\/h3> <p> `processModuleInputs` a visioneval framework control function that processes input files identified in a module's 'Inp' specifications in preparation for saving in the datastore.<\/p> <h3>Details<\/h3> <p> This function processes the input files identified in a module's 'Inp' specifications in preparation for saving the data in the datastore. Several processes are carried out. The existence of each specified input file is checked. Any file whose corresponding 'GROUP' specification is 'Year', is checked to determine that it has 'Year' and 'Geo' columns. The entries in the 'Year' and 'Geo' columns are checked to make sure they are complete and there are no duplicates. Any file whose 'GROUP' specification is 'Global' or 'BaseYear' and whose 'TABLE' specification is a geographic specification other than 'Region' is checked to determine if it has a 'Geo' column and the entries are checked for completeness. The data in each column are checked against specifications to determine conformance. The function returns a list which contains a list of error messages and a list of the data inputs. The function also writes error messages and warnings to the log file.<\/p> <h3>Arguments<\/h3> <ul> <li>ModuleSpec_ls: a list of module specifications that is consistent with the VisionEval requirements.<\/li> <li>ModuleName: a string identifying the name of the module (used to document module in error messages).<\/li> <li>Dir: a string identifying the relative path to the directory where the model inputs are contained.<\/li> <\/ul> <h3>Return Value<\/h3> <p> A list containing the results of the input processing. The list has two components. The first (Errors) is a vector of identified file and data errors. The second (Data) is a list containing the data in the input files organized in the standard format for data exchange with the datastore.<\/p>"},
{"name":"processModuleSpecs","details":"<h2>Function: processModuleSpecs<\/h2> <h3>Description<\/h3> <p> `processModuleSpecs` a visioneval framework control function that processes a full module specifications list, expanding all elements in the Inp, Get, and Set components by parsing the UNITS attributes and duplicating every specification which has multiple values for the NAME attribute.<\/p> <h3>Details<\/h3> <p> This function process a module specification list. If any of the specifications include multiple listings of data sets (i.e. fields) in a table, this function expands the listing to establish a separate specification for each data set.<\/p> <h3>Arguments<\/h3> <ul> <li>Spec_ls: A specifications list.<\/li> <\/ul> <h3>Return Value<\/h3> <p> A standard specifications list with expansion of the multiple item specifications.<\/p>"},
{"name":"readGeography","details":"<h2>Function: readGeography<\/h2> <h3>Description<\/h3> <p> `readGeography` a visioneval framework control function that reads the geographic specifications file for the model.<\/p> <h3>Details<\/h3> <p> This function manages the reading and error checking of geographic specifications for the model. It calls the checkGeography function to check for errors in the specifications. The checkGeography function reads in the file and checks for errors. It returns a list of any errors that are found and a data frame containing the geographic specifications. If errors are found, the functions writes the errors to a log file and stops model execution. If there are no errors, the function adds the geographic in the geographic specifications file, the errors are written to the log file and execution stops. If no errors are found, the geographic specifications are added to the model state file.<\/p> <h3>Arguments<\/h3> <ul> <li>Dir: A string identifying the path to the geographic specifications file. Note: don't include the final separator in the path name 'e.g. not defs/'.<\/li> <li>GeoFile: A string identifying the name of the geographic specifications file. This is a csv-formatted text file which contains columns named 'Azone', 'Bzone', 'Czone', and 'Marea'. The 'Azone' column must have zone names in all rows. The 'Bzone' and 'Czone' columns can be unspecified (NA in all rows) or may have have unique names in every row. The 'Marea' column (referring to metropolitan areas) identifies metropolitan areas corresponding to the most detailed level of specified geography (or 'None' no metropolitan area occupies any portion of the zone.<\/li> <\/ul> <h3>Return Value<\/h3> <p> The value TRUE is returned if the function is successful at reading the file and the specifications are consistent. It stops if there are any errors in the specifications. All of the identified errors are written to the run log. A data frame containing the file entries is added to the model state file as Geo_df'.<\/p>"},
{"name":"readModelState","details":"<h2>Function: readModelState<\/h2> <h3>Description<\/h3> <p> `readModelState` a visioneval framework control function that reads components of the file that saves a copy of the model state.<\/p> <h3>Details<\/h3> <p> The model state is stored in a list (ModelState_ls) that is also saved as a file (ModelState.Rda) whenever the list is updated. This function reads the contents of the ModelState.Rda file.<\/p> <h3>Arguments<\/h3> <ul> <li>Names_: A string vector of the components to extract from the ModelState_ls list.<\/li> <li>FileName: A string vector with the full path name of the model state file.<\/li> <\/ul> <h3>Return Value<\/h3> <p> A list containing the specified components from the model state file.<\/p>"},
{"name":"setInDatastore","details":"<h2>Function: setInDatastore<\/h2> <h3>Description<\/h3> <p> `setInDatastore` a visioneval framework control function saves to the datastore the data returned in a standard list by a module.<\/p> <h3>Details<\/h3> <p> This function saves to the datastore the data sets identified in a module's 'Set' specifications and included in the list returned by the module. If a particular geographic area is identified, the data are saved to the positions in the data sets in the datastore corresponding to the identified geographic area.<\/p> <h3>Arguments<\/h3> <ul> <li>Data_ls: a list containing the data to be saved. The list is organized by group, table, and data set.<\/li> <li>ModuleSpec_ls: a list of module specifications that is consistent with the VisionEval requirements<\/li> <li>ModuleName: a string identifying the name of the module (used to document the module creating the data in the datastore)<\/li> <li>Year: a string identifying the model run year<\/li> <li>Geo: a string identifying the name of the geographic area to get the data for. For example, if the module is specified to be run by Azone, then Geo would be the name of a particular Azone.<\/li> <li>GeoIndex_ls: a list of geographic indices used to determine the positions to extract from a dataset corresponding to the specified geography.<\/li> <\/ul> <h3>Return Value<\/h3> <p> A logical value which is TRUE if the data are successfully saved to the datastore.<\/p>"},
{"name":"setModelState","details":"<h2>Function: setModelState<\/h2> <h3>Description<\/h3> <p> `setModelState` a visioneval framework control function that updates the list that keeps track of the model state with list of components to update and resaves in the model state file.<\/p> <h3>Details<\/h3> <p> Key variables that are important for managing the model run are stored in a list (ModelState_ls) that is in the global workspace and saved in the 'ModelState.Rda' file. This function updates  entries in the model state list with a supplied named list of values, and then saves the results in the file.<\/p> <h3>Arguments<\/h3> <ul> <li>ChangeState_ls: A named list of components to change in ModelState_ls<\/li> <li>FileName: A string identifying the name of the file that contains the ModelState_ls list. The default name is 'ModelState.Rda'.<\/li> <\/ul> <h3>Return Value<\/h3> <p> TRUE if the model state list and file are changed.<\/p>"},
{"name":"simDataTransactions","details":"<h2>Function: simDataTransactions<\/h2> <h3>Description<\/h3> <p> `simDataTransactions` a visioneval framework control function that loads all module specifications in order (by run year) and creates a simulated listing of the data which is in the datastore and the requests of data from the datastore and checks whether tables will be present to put datasets in and that datasets will be present that data is to be retrieved from.<\/p> <h3>Details<\/h3> <p> This function creates a list of the datastore listings for the working datastore and for all datastore references. The list includes a 'Global' component, in which 'Global' references are simulated, components for each model run year, in which 'Year' references are simulated, and if the base year is not one of the run years, a base year component, in which base year references are simulated. For each model run year the function steps through a data frame of module calls as produced by 'parseModelScript', and loads and processes the module specifications in order: adds 'NewInpTable' references, adds 'Inp' dataset references, checks whether references to datasets identified in 'Get' specifications are present, adds 'NewSetTable' references, and adds 'Set' dataset references. The function compiles a vector of error and warning messages. Error messages are made if: 1) a 'NewInpTable' or 'NewSetTable' specification of a module would create a new table for a table that already exists; 2) a dataset identified by a 'Get' specification would not be present in the working datastore or any referenced datastores; 3) the 'Get' specifications for a dataset would not be consistent with the specifications for the dataset in the datastore. The function compiles warnings if a 'Set' specification will cause existing data in the working datastore to be overwritten. The function writes warning and error messages to the log and stops program execution if there are any errors.<\/p> <h3>Arguments<\/h3> <ul> <li>AllSpecs_ls: A list containing the processed specifications of all of the modules run by model script in the order that the modules are called with duplicated module calls removed. Information about each module call is a component of the list in the order of the module calls. Each component is composed of 3 components: 'ModuleName' contains the name of the module, 'PackageName' contains the name of the package the module is in, and 'Specs' contains the processed specifications of the module. The 'Get' specification component includes the 'Get' specifications of all modules that are called by the module.<\/li> <\/ul> <h3>Return Value<\/h3> <p> There is no return value. The function has the side effect of writing messages to the log and stops program execution if there are any errors.<\/p>"},
{"name":"sortGeoTable","details":"<h2>Function: sortGeoTable<\/h2> <h3>Description<\/h3> <p> `sortGeoTable` a visioneval framework control function that returns a data frame whose rows are sorted to match the geography in a specified table in the datastore.<\/p> <h3>Details<\/h3> <p> This function sorts the rows of a data frame that the 'Geo' field in the data frame matches the corresponding geography names in the specified table in the datastore. The function returns the sorted table.<\/p> <h3>Arguments<\/h3> <ul> <li>Data_df: a data frame that contains a 'Geo' field containing the names of the geographic areas to sort by and any number of additional data fields.<\/li> <li>Table: a string for the table that is to be matched against.<\/li> <li>Group: a string for the generic group that the table resides in.<\/li> <\/ul> <h3>Return Value<\/h3> <p> The data frame which has been sorted to match the order of geography in the specified table in the datastore.<\/p>"},
{"name":"SpecRequirements","details":"<h2>Function: SpecRequirements<\/h2> <h3>Description<\/h3> <p> `SpecRequirements` a visioneval framework control function that returns a list of basic requirements for module specifications to be used for checking correctness of specifications.<\/p> <h3>Details<\/h3> <p> This function returns a list of the basic requirements for module specifications. The main components of the list are the components of module specifications: RunBy, NewInpTable, NewSetTable, Inp, Get, Set. For each item of each module specifications component, the list identifies the required data type of the attribute entry and the allowed values for the attribute entry.<\/p> <h3>Arguments<\/h3> <ul> <li>None<\/li> <\/ul> <h3>Return Value<\/h3> <p> A list comprised of six named components: RunBy, NewInpTable, NewSetTable, Inp, Get, Set. Each main component is a list that has a component for each specification item that has values to be checked. For each such item there is a list having two components: ValueType and ValuesAllowed. The ValueType component identifies the data type that the data entry for the item must have (e.g. character, integer). The ValuesAllowed item identifies what values the item may have.<\/p>"},
{"name":"Types","details":"<h2>Function: Types<\/h2> <h3>Description<\/h3> <p> `Types` a visioneval framework control function that returns a list of returns a list of recognized data types, the units for each type, and storage mode of each type.<\/p> <h3>Details<\/h3> <p> This function stores a listing of the dataset types recognized by the visioneval framework, the units recognized for each type, and the storage mode used for each type. Types include simple types (e.g. integer, double, character, logical) as well as complex types (e.g. distance, time, mass). For the complex types, units are specified as well. For example for the distance type, allowed units are MI (miles), FT (feet), KM (kilometers), M (meters). The listing includes conversion factors between units of each complex type. The listing also contains the storage mode (i.e. integer, double, character, logical of each type. For simple types, the type and the storage mode are the same).<\/p> <h3>Arguments<\/h3> <ul> <li>None<\/li> <\/ul> <h3>Return Value<\/h3> <p> A list containing a component for each recognized type. Each component lists the recognized units for the type and the storage mode. There are currently 4 simple types and 10 complex type. The simple types are integer, double, character and logical. The complex types are currency, distance, area, mass, volume, time, speed, vehicle_distance, passenger_distance, and payload_distance.<\/p>"},
{"name":"writeLog","details":"<h2>Function: writeLog<\/h2> <h3>Description<\/h3> <p> `writeLog` a visioneval framework control function that writes a message to the run log.<\/p> <h3>Details<\/h3> <p> This function writes a message in the form of a string to the run log. It logs the time as well as the message to the run log.<\/p> <h3>Arguments<\/h3> <ul> <li>Msg: A character string.<\/li> <li>Print: logical (default: FALSE). If True Msg will be printed in additon to being added to log<\/li> <\/ul> <h3>Return Value<\/h3> <p> TRUE if the message is written to the log uccessfully. It appends the time and the message text to the run log.<\/p>"},
{"name":"writeVENameRegistry","details":"<h2>Function: writeVENameRegistry<\/h2> <h3>Description<\/h3> <p> `writeVENameRegistry` a visioneval framework control function that writes module Inp and Set specifications to the VisionEval name registry.<\/p> <h3>Details<\/h3> <p> The VisionEval name registry (VENameRegistry.json) keeps track of the dataset names created by all registered modules by reading in datasets specified in the module Inp specifications or by returning calculated datasets as specified in the module Set specifications. This functions adds the Inp and Set specifications for a module to the registry. It removes any existing entries for the module first.<\/p> <h3>Arguments<\/h3> <ul> <li>ModuleName: a string identifying the module name.<\/li> <li>PackageName: a string identifying the package name.<\/li> <li>NameRegistryDir: a string identifying the path to the directory where the name registry file is located.<\/li> <\/ul> <h3>Return Value<\/h3> <p> TRUE if successful. Has a side effect of updating the VisionEval name registry.<\/p>"},
{"name":"initDatasetRD","details":"<h2>Function: initDatasetRD<\/h2> <h3>Description<\/h3> <p> `initDatasetRD` a visioneval framework datastore connection function initializes a dataset in an RData (RD) type datastore table.<\/p> <h3>Details<\/h3> <p> This function initializes a dataset in an RData (RD) type datastore table.<\/p> <h3>Arguments<\/h3> <ul> <li>Spec_ls: a list containing the standard module specifications described in the model system design documentation.<\/li> <li>Group: a string representation of the name of the top-level subdirectory the table is to be created in (i.e. either 'Global' or the name of the year).<\/li> <\/ul> <h3>Return Value<\/h3> <p> TRUE if dataset is successfully initialized. If the identified table does not exist, the function throws an error.<\/p>"},
{"name":"initDatastoreRD","details":"<h2>Function: initDatastoreRD<\/h2> <h3>Description<\/h3> <p> `initDatastoreRD` a visioneval framework datastore connection function that creates a datastore with starting structure for an RData (RD) type datastore.<\/p> <h3>Details<\/h3> <p> This function creates the datastore for the model run with the initial structure for an RData (RD) type datastore.<\/p> <h3>Arguments<\/h3> <ul> <li>None<\/li> <\/ul> <h3>Return Value<\/h3> <p> TRUE if datastore initialization is successful. Calls the listDatastore function which adds a listing of the datastore contents to the model state file.<\/p>"},
{"name":"initTableRD","details":"<h2>Function: initTableRD<\/h2> <h3>Description<\/h3> <p> `initTableRD` a visioneval framework datastore connection function initializes a table in an RData (RD) type datastore.<\/p> <h3>Details<\/h3> <p> This function initializes a table in an RData (RD) type datastore.<\/p> <h3>Arguments<\/h3> <ul> <li>Table: a string identifying the name of the table to initialize.<\/li> <li>Group: a string representation of the name of the top-level subdirectory the table is to be created in (i.e. either 'Global' or the name of the year).<\/li> <li>Length: a number identifying the table length.<\/li> <\/ul> <h3>Return Value<\/h3> <p> The value TRUE is returned if the function is successful at creating the table. In addition, the listDatastore function is run to update the inventory in the model state file. The function stops if the group in which the table is to be placed does not exist in the datastore and a message is written to the log.<\/p>"},
{"name":"listDatastoreRD","details":"<h2>Function: listDatastoreRD<\/h2> <h3>Description<\/h3> <p> `listDatastoreRD` a visioneval framework datastore connection function that lists the contents of an RData (RD) type datastore.<\/p> <h3>Details<\/h3> <p> This function lists the contents of a datastore for an RData (RD) type datastore.<\/p> <h3>Arguments<\/h3> <ul> <li>DataListing_ls: a list containing named elements describing a new data item being added to the datastore listing and the model state file. The list components are: group - the name of the group (path) the item is being added to; name - the name of the data item (directory or dataset); groupname - the full path to the data item; attributes - a list containing the named attributes of the data item.<\/li> <\/ul> <h3>Return Value<\/h3> <p> TRUE if the listing is successfully read from the datastore and written to the model state file.<\/p>"},
{"name":"readFromTableRD","details":"<h2>Function: readFromTableRD<\/h2> <h3>Description<\/h3> <p> `readFromTableRD` a visioneval framework datastore connection function that reads a dataset from an RData (RD) type datastore table.<\/p> <h3>Details<\/h3> <p> This function reads a dataset from an RData (RD) type datastore table.<\/p> <h3>Arguments<\/h3> <ul> <li>Name: A string identifying the name of the dataset to be read from.<\/li> <li>Table: A string identifying the complete name of the table where the dataset is located.<\/li> <li>Group: a string representation of the name of the datastore group the data is to be read from.<\/li> <li>DstoreLoc: a string representation of the file path of the datastore. NULL if the datastore is the current directory.<\/li> <li>Index: A numeric vector identifying the positions the data is to be written to. NULL if the entire dataset is to be read.<\/li> <li>ReadAttr: A logical identifying whether to return the attributes of the stored dataset. The default value is FALSE.<\/li> <\/ul> <h3>Return Value<\/h3> <p> A vector of the same type stored in the datastore and specified in the TYPE attribute.<\/p>"},
{"name":"writeToTableRD","details":"<h2>Function: writeToTableRD<\/h2> <h3>Description<\/h3> <p> `writeToTableRD` a visioneval framework datastore connection function that writes data to an RData (RD) type datastore table and initializes dataset if needed.<\/p> <h3>Details<\/h3> <p> This function writes a dataset file to an RData (RD) type datastore table. It initializes the dataset if the dataset does not exist. Enables data to be written to specific location indexes in the dataset.<\/p> <h3>Arguments<\/h3> <ul> <li>Data_: A vector of data to be written.<\/li> <li>Spec_ls: a list containing the standard module 'Set' specifications described in the model system design documentation.<\/li> <li>Group: a string representation of the name of the datastore group the data is to be written to.<\/li> <li>Index: A numeric vector identifying the positions the data is to be written to.<\/li> <\/ul> <h3>Return Value<\/h3> <p> TRUE if data is sucessfully written.<\/p>"}
];
